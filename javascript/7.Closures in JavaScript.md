# Closures in JavaScript - ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶ó‡¶æ‡¶á‡¶° ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶Ø‡¶º

## Closure ‡¶ï‡¶ø?

**Closure** ‡¶Æ‡¶æ‡¶®‡ßá ‡¶π‡¶ö‡ßç‡¶õ‡ßá ‚Äî

> ‡¶Ø‡¶ñ‡¶® ‡¶ï‡ßã‡¶®‡ßã function ‡¶§‡¶æ‡¶∞ ‡¶®‡¶ø‡¶ú‡ßá‡¶∞ **scope ‡¶è‡¶∞ ‡¶¨‡¶æ‡¶á‡¶∞‡ßá ‡¶•‡¶æ‡¶ï‡¶æ variable** ‡¶ï‡ßá access ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá, ‡¶è‡¶Æ‡¶®‡¶ï‡¶ø function ‡¶ü‡¶ø **return ‡¶π‡ßü‡ßá ‡¶Ø‡¶æ‡¶ì‡ßü‡¶æ‡¶∞ ‡¶™‡¶∞‡ßá‡¶ì**, ‡¶§‡¶ñ‡¶® ‡¶§‡¶æ‡¶ï‡ßá **closure** ‡¶¨‡¶≤‡ßá‡•§

‡¶∏‡¶π‡¶ú‡¶≠‡¶æ‡¶¨‡ßá ‡¶¨‡¶≤‡¶≤‡ßá ‚Äî

> ‡¶è‡¶ï‡¶ü‡¶æ function ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶è‡¶ï‡¶ü‡¶æ function ‡¶è‡¶∞ ‡¶≠‡¶ø‡¶§‡¶∞‡ßá declare ‡¶ï‡¶∞‡¶æ ‡¶π‡¶≤‡ßá, inner function ‡¶ü‡¶ø outer function ‡¶è‡¶∞ variable ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶Æ‡¶®‡ßá ‡¶∞‡¶æ‡¶ñ‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá ‚Äî ‡¶è‡¶á ‚Äú‡¶Æ‡¶®‡ßá ‡¶∞‡¶æ‡¶ñ‡¶æ‚Äù ‡¶Ü‡¶ö‡¶∞‡¶£‡¶ü‡¶æ‡¶á closure‡•§

---

**Closure** ‡¶π‡¶≤‡ßã ‡¶è‡¶ï‡¶ü‡¶ø function ‡¶Ø‡¶æ ‡¶§‡¶æ‡¶∞ **outer (parent) function ‡¶è‡¶∞ variables** ‡¶ï‡ßá access ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá, ‡¶è‡¶Æ‡¶®‡¶ï‡¶ø outer function execute ‡¶π‡¶Ø‡¶º‡ßá ‡¶∂‡ßá‡¶∑ ‡¶π‡¶Ø‡¶º‡ßá ‡¶ó‡ßá‡¶≤‡ßá‡¶ì‡•§

### Simple Definition:

> "A closure is a function bundled together with its lexical environment."

‡¶Ö‡¶∞‡ßç‡¶•‡¶æ‡ßé, function + ‡¶§‡¶æ‡¶∞ surrounding state (variables) = Closure

## Basic Example

```javascript
function outer() {
  const message = "Hello";

  function inner() {
    console.log(message); // outer ‡¶è‡¶∞ variable access ‡¶ï‡¶∞‡¶õ‡ßá
  }

  return inner;
}

const myFunc = outer(); // outer() execute ‡¶∂‡ßá‡¶∑
myFunc(); // "Hello" - ‡¶è‡¶ñ‡¶®‡¶ì message access ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶õ‡ßá!
```

**‡¶ï‡¶ø ‡¶π‡¶ö‡ßç‡¶õ‡ßá?**

1. `outer()` call ‡¶π‡¶≤‡ßã ‡¶è‡¶¨‡¶Ç `inner` function return ‡¶ï‡¶∞‡¶≤‡ßã
2. `outer()` execution ‡¶∂‡ßá‡¶∑ (normally ‡¶è‡¶∞ variables destroy ‡¶π‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶ï‡¶•‡¶æ)
3. ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ `myFunc()` call ‡¶ï‡¶∞‡¶≤‡ßá ‡¶è‡¶ñ‡¶®‡¶ì `message` access ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶õ‡ßá
4. ‡¶è‡¶ü‡¶æ‡¶á **Closure**! üéâ

## üß© ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ ‡ßß: ‡¶∏‡¶π‡¶ú ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£

```js
function outer() {
  let count = 0; // outer function variable

  function inner() {
    count++;
    console.log(count);
  }

  return inner;
}

const counter = outer(); // outer() return ‡¶ï‡¶∞‡¶õ‡ßá inner function
counter(); // 1
counter(); // 2
counter(); // 3
```

### üß† ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ:

- `outer()` ‡¶è‡¶ï‡¶¨‡¶æ‡¶∞ execute ‡¶π‡ßü‡ßá ‡¶∂‡ßá‡¶∑ ‡¶π‡ßü‡ßá ‡¶ó‡ßá‡¶õ‡ßá‡•§
- ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ `inner()` ‡¶è‡¶ñ‡¶®‡ßã `count` variable access ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶õ‡ßá‡•§
- ‡¶ï‡¶æ‡¶∞‡¶£ **closure** ‡¶§‡ßà‡¶∞‡¶ø ‡¶π‡ßü‡ßá‡¶õ‡ßá ‚Äî inner function ‡¶è‡¶∞ ‡¶≠‡¶ø‡¶§‡¶∞ ‡¶•‡ßá‡¶ï‡ßá outer function ‡¶è‡¶∞ variable ‡¶ï‡ßá ‚Äúcapture‚Äù ‡¶ï‡¶∞‡ßá ‡¶∞‡ßá‡¶ñ‡ßá‡¶õ‡ßá‡•§

---

## üß© ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ ‡ß®: Data Privacy / Encapsulation

Closures data hide ‡¶¨‡¶æ protect ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø‡¶ì ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶π‡ßü‡•§

```js
function createBankAccount() {
  let balance = 1000; // private variable

  return {
    deposit(amount) {
      balance += amount;
      console.log(`Deposited: ${amount}`);
    },
    withdraw(amount) {
      if (amount <= balance) {
        balance -= amount;
        console.log(`Withdrew: ${amount}`);
      } else {
        console.log("Insufficient balance");
      }
    },
    getBalance() {
      return balance;
    },
  };
}

const account = createBankAccount();
account.deposit(500);
account.withdraw(200);
console.log(account.getBalance()); // 1300
```

### ‚öôÔ∏è ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ:

- `balance` variable ‡¶¨‡¶æ‡¶á‡¶∞‡ßá ‡¶•‡ßá‡¶ï‡ßá access ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü ‡¶®‡¶æ‡•§
- ‡¶∂‡ßÅ‡¶ß‡ßÅ `deposit`, `withdraw`, ‡¶è‡¶¨‡¶Ç `getBalance` ‡¶è‡¶á function ‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá‡¶á access ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü‡•§
  üëâ ‡¶è‡¶ü‡¶ø closure ‡¶è‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá **data encapsulation**‡•§

---

## üß© ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ ‡ß©: setTimeout ‡¶è‡¶¨‡¶Ç Closure

```js
function greet(name) {
  setTimeout(() => {
    console.log(`Hello, ${name}!`);
  }, 2000);
}

greet("Ripon");
```

### üîç ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ:

- `setTimeout` asynchronous ‡¶π‡¶ì‡ßü‡¶æ‡ßü `greet()` function ‡¶∂‡ßá‡¶∑ ‡¶π‡ßü‡ßá ‡¶Ø‡¶æ‡ßü‡•§
- ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ arrow function ‡¶è‡¶ñ‡¶®‡ßã `name` variable access ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá ‚Äî ‡¶è‡¶ü‡¶æ closure ‡¶è‡¶∞ ‡¶ï‡¶æ‡¶∞‡¶£‡ßá‡•§

---

## üß© ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ ‡ß™: Loop + Closure (Classic Interview Example)

```js
for (var i = 1; i <= 3; i++) {
  setTimeout(() => console.log(i), 1000);
}
// Output: 4, 4, 4
```

### ‚ö†Ô∏è ‡¶ï‡¶æ‡¶∞‡¶£:

`var` function scoped, ‡¶§‡¶æ‡¶á ‡¶∏‡¶¨ callback ‡¶è‡¶ï‡¶á `i` reference ‡¶ï‡¶∞‡ßá‡•§

---

‚úÖ ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶® `let` ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá:

```js
for (let i = 1; i <= 3; i++) {
  setTimeout(() => console.log(i), 1000);
}
// Output: 1, 2, 3
```

### üîç ‡¶ï‡¶æ‡¶∞‡¶£:

`let` block scoped, ‡¶§‡¶æ‡¶á ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶¨‡¶æ‡¶∞ loop ‡¶è ‡¶®‡¶§‡ßÅ‡¶® closure ‡¶§‡ßà‡¶∞‡¶ø ‡¶π‡ßü‡•§

---

## Closure ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá?

### Memory Perspective:

```javascript
function createCounter() {
  let count = 0; // Private variable

  return function () {
    count++;
    return count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

**What's happening in memory:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Global Execution Context           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  counter: function() {...}          ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ  ‚Üì Closure Scope                   ‚îÇ
‚îÇ  count: 3 ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ                              ‚îÇ     ‚îÇ
‚îÇ  counter function ‡¶è‡¶∞ access  ‚îÇ     ‚îÇ
‚îÇ  ‡¶Ü‡¶õ‡ßá count variable ‡¶è        ‚îÇ     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

`count` variable garbage collect ‡¶π‡¶Ø‡¶º ‡¶®‡¶æ ‡¶ï‡¶æ‡¶∞‡¶£ returned function ‡¶è‡¶ñ‡¶®‡¶ì ‡¶è‡¶ü‡¶æ reference ‡¶ï‡¶∞‡¶õ‡ßá‡•§

## Lexical Scoping

Closure ‡¶¨‡ßÅ‡¶ù‡¶§‡ßá ‡¶π‡¶≤‡ßá **Lexical Scoping** ‡¶¨‡ßÅ‡¶ù‡¶§‡ßá ‡¶π‡¶¨‡ßá‡•§

```javascript
const name = "Global";

function outer() {
  const name = "Outer";

  function middle() {
    const name = "Middle";

    function inner() {
      console.log(name); // ‡¶ï‡ßã‡¶® name print ‡¶π‡¶¨‡ßá?
    }

    inner();
  }

  middle();
}

outer(); // "Middle"
```

**Lexical Scoping Rule:**
Function ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá **define** ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá, ‡¶∏‡ßá‡¶ñ‡¶æ‡¶®‡¶ï‡¶æ‡¶∞ scope access ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡•§

### Scope Chain:

```
inner() ‚Üí middle() ‚Üí outer() ‚Üí Global
  ‚Üì         ‚Üì          ‚Üì         ‚Üì
 name?   name="Middle" name    name
         ‚úÖ Found!
```

## Real-World Examples

### Example 1: Private Variables (Data Privacy)

```javascript
function createBankAccount(initialBalance) {
  let balance = initialBalance; // Private variable

  return {
    deposit: function (amount) {
      if (amount > 0) {
        balance += amount;
        return `Deposited: ${amount}. New balance: ${balance}`;
      }
    },

    withdraw: function (amount) {
      if (amount > 0 && amount <= balance) {
        balance -= amount;
        return `Withdrawn: ${amount}. New balance: ${balance}`;
      }
      return "Insufficient funds";
    },

    getBalance: function () {
      return balance;
    },
  };
}

const myAccount = createBankAccount(1000);

console.log(myAccount.getBalance()); // 1000
console.log(myAccount.deposit(500)); // "Deposited: 500. New balance: 1500"
console.log(myAccount.withdraw(200)); // "Withdrawn: 200. New balance: 1300"
console.log(myAccount.balance); // undefined - direct access ‡¶®‡¶æ‡¶á!
```

**Benefits:**

- `balance` ‡¶ï‡ßá directly access/modify ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶ö‡ßç‡¶õ‡ßá ‡¶®‡¶æ
- ‡¶∂‡ßÅ‡¶ß‡ßÅ provided methods ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá change ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá
- Data encapsulation ‡¶è‡¶¨‡¶Ç security

### Example 2: Function Factory

```javascript
function createMultiplier(multiplier) {
  return function (number) {
    return number * multiplier;
  };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);
const quadruple = createMultiplier(4);

console.log(double(5)); // 10
console.log(triple(5)); // 15
console.log(quadruple(5)); // 20
```

‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶æ function ‡¶®‡¶ø‡¶ú‡¶∏‡ßç‡¶¨ `multiplier` remember ‡¶ï‡¶∞‡ßá ‡¶∞‡¶æ‡¶ñ‡ßá!

### Example 3: Counter (Multiple Instances)

```javascript
function createCounter(initialValue = 0) {
  let count = initialValue;

  return {
    increment: function () {
      count++;
      return count;
    },
    decrement: function () {
      count--;
      return count;
    },
    reset: function () {
      count = initialValue;
      return count;
    },
    getValue: function () {
      return count;
    },
  };
}

const counter1 = createCounter(0);
const counter2 = createCounter(100);

console.log(counter1.increment()); // 1
console.log(counter1.increment()); // 2
console.log(counter2.increment()); // 101
console.log(counter2.increment()); // 102

// ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶æ counter ‡¶®‡¶ø‡¶ú‡¶∏‡ßç‡¶¨ count maintain ‡¶ï‡¶∞‡¶õ‡ßá!
```

### Example 4: Event Handlers

```javascript
function setupButtons() {
  const buttons = document.querySelectorAll(".btn");

  for (let i = 0; i < buttons.length; i++) {
    buttons[i].addEventListener("click", function () {
      console.log(`Button ${i} clicked`);
      // ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶æ function ‡¶®‡¶ø‡¶ú‡¶∏‡ßç‡¶¨ 'i' value remember ‡¶ï‡¶∞‡ßá
    });
  }
}

// ‚ùå var ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá problem:
function setupButtonsWrong() {
  const buttons = document.querySelectorAll(".btn");

  for (var i = 0; i < buttons.length; i++) {
    buttons[i].addEventListener("click", function () {
      console.log(`Button ${i} clicked`);
      // ‡¶∏‡¶¨ button click ‡¶ï‡¶∞‡¶≤‡ßá same 'i' value (last value)
    });
  }
}
```

### Example 5: Memoization (Performance Optimization)

```javascript
function memoize(fn) {
  const cache = {}; // Closure ‡¶è stored

  return function (...args) {
    const key = JSON.stringify(args);

    if (key in cache) {
      console.log("From cache");
      return cache[key];
    }

    console.log("Calculating...");
    const result = fn(...args);
    cache[key] = result;
    return result;
  };
}

// Heavy computation function
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoizedFib = memoize(fibonacci);

console.log(memoizedFib(10)); // Calculating... 55
console.log(memoizedFib(10)); // From cache 55
console.log(memoizedFib(10)); // From cache 55
```

### Example 6: Module Pattern

```javascript
const calculator = (function () {
  // Private variables ‡¶è‡¶¨‡¶Ç functions
  let result = 0;

  function log(message) {
    console.log(`[Calculator] ${message}`);
  }

  // Public API return ‡¶ï‡¶∞‡¶õ‡ßá
  return {
    add: function (x) {
      result += x;
      log(`Added ${x}. Result: ${result}`);
      return this;
    },

    subtract: function (x) {
      result -= x;
      log(`Subtracted ${x}. Result: ${result}`);
      return this;
    },

    multiply: function (x) {
      result *= x;
      log(`Multiplied by ${x}. Result: ${result}`);
      return this;
    },

    getResult: function () {
      return result;
    },

    reset: function () {
      result = 0;
      log("Reset");
      return this;
    },
  };
})(); // IIFE - Immediately Invoked

// Usage (Method chaining):
calculator.add(10).multiply(2).subtract(5);

console.log(calculator.getResult()); // 15
console.log(calculator.result); // undefined - private!
```

## Common Closure Patterns

### Pattern 1: Once Function (Execute ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶è‡¶ï‡¶¨‡¶æ‡¶∞)

```javascript
function once(fn) {
  let called = false;
  let result;

  return function (...args) {
    if (!called) {
      called = true;
      result = fn(...args);
    }
    return result;
  };
}

const initialize = once(() => {
  console.log("Initializing...");
  return "Initialized!";
});

console.log(initialize()); // "Initializing..." "Initialized!"
console.log(initialize()); // "Initialized!" (function call ‡¶π‡¶Ø‡¶º ‡¶®‡¶ø)
console.log(initialize()); // "Initialized!" (function call ‡¶π‡¶Ø‡¶º ‡¶®‡¶ø)
```

### Pattern 2: Debounce (Performance Optimization)

```javascript
function debounce(fn, delay) {
  let timeoutId;

  return function (...args) {
    clearTimeout(timeoutId);

    timeoutId = setTimeout(() => {
      fn(...args);
    }, delay);
  };
}

// Search input ‡¶è ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞
const searchInput = document.getElementById("search");
const handleSearch = debounce((value) => {
  console.log("Searching for:", value);
  // API call ‡¶ï‡¶∞‡ßã
}, 500);

searchInput.addEventListener("input", (e) => {
  handleSearch(e.target.value);
});
// User typing ‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡¶æ‡¶∞ 500ms ‡¶™‡¶∞‡ßá search ‡¶π‡¶¨‡ßá
```

### Pattern 3: Throttle

```javascript
function throttle(fn, limit) {
  let inThrottle;

  return function (...args) {
    if (!inThrottle) {
      fn(...args);
      inThrottle = true;

      setTimeout(() => {
        inThrottle = false;
      }, limit);
    }
  };
}

// Scroll event ‡¶è ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞
const handleScroll = throttle(() => {
  console.log("Scrolling...");
}, 1000);

window.addEventListener("scroll", handleScroll);
// ‡¶™‡ßç‡¶∞‡¶§‡¶ø 1 second ‡¶è maximum ‡¶è‡¶ï‡¶¨‡¶æ‡¶∞ execute ‡¶π‡¶¨‡ßá
```

### Pattern 4: Curry Function

```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn(...args);
    }

    return function (...nextArgs) {
      return curried(...args, ...nextArgs);
    };
  };
}

// Usage:
function add(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);

console.log(curriedAdd(1)(2)(3)); // 6
console.log(curriedAdd(1, 2)(3)); // 6
console.log(curriedAdd(1)(2, 3)); // 6
console.log(curriedAdd(1, 2, 3)); // 6
```

### Pattern 5: Private Counter with Multiple Methods

```javascript
function createSecureCounter() {
  let count = 0;
  const history = [];

  function logAction(action, value) {
    history.push({
      action,
      value,
      timestamp: new Date(),
    });
  }

  return {
    increment: function (step = 1) {
      count += step;
      logAction("increment", step);
      return count;
    },

    decrement: function (step = 1) {
      count -= step;
      logAction("decrement", step);
      return count;
    },

    getValue: function () {
      return count;
    },

    getHistory: function () {
      return [...history]; // Copy return ‡¶ï‡¶∞‡¶õ‡ßá
    },

    reset: function () {
      count = 0;
      logAction("reset", 0);
      return count;
    },
  };
}

const counter = createSecureCounter();
counter.increment(5);
counter.increment(3);
counter.decrement(2);
console.log(counter.getValue()); // 6
console.log(counter.getHistory()); // Array of actions
```

## Closure ‡¶è‡¶∞ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶è‡¶¨‡¶Ç ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®

### Problem 1: Loop ‡¶è Closure (Classic Interview Question)

```javascript
// ‚ùå Problem: ‡¶∏‡¶¨ ‡¶è‡¶ï‡¶á value print ‡¶ï‡¶∞‡¶¨‡ßá
for (var i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i); // 5, 5, 5, 5, 5
  }, 1000);
}

// ‚úÖ Solution 1: let ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßã (Block scope)
for (let i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i); // 0, 1, 2, 3, 4
  }, 1000);
}

// ‚úÖ Solution 2: IIFE (Immediately Invoked Function Expression)
for (var i = 0; i < 5; i++) {
  (function (j) {
    setTimeout(function () {
      console.log(j); // 0, 1, 2, 3, 4
    }, 1000);
  })(i);
}

// ‚úÖ Solution 3: Helper function
for (var i = 0; i < 5; i++) {
  createTimeout(i);
}

function createTimeout(index) {
  setTimeout(function () {
    console.log(index); // 0, 1, 2, 3, 4
  }, 1000);
}
```

**‡¶ï‡ßá‡¶® Problem ‡¶π‡¶Ø‡¶º:**

- `var` function-scoped, ‡¶§‡¶æ‡¶á ‡¶è‡¶ï‡¶ü‡¶æ ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ `i` variable share ‡¶ï‡¶∞‡ßá
- Loop ‡¶∂‡ßá‡¶∑‡ßá `i` = 5
- setTimeout execute ‡¶π‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶∏‡¶¨ closure same `i` ‡¶¶‡ßá‡¶ñ‡ßá (‡¶Ø‡¶æ‡¶∞ value 5)

### Problem 2: Memory Leak

```javascript
// ‚ùå Memory leak potential
function createHugeArray() {
  const hugeArray = new Array(1000000).fill("data");

  return function () {
    console.log(hugeArray[0]); // Entire array in closure!
  };
}

const fn = createHugeArray(); // hugeArray memory ‡¶§‡ßá ‡¶•‡ßá‡¶ï‡ßá ‡¶Ø‡¶æ‡¶Ø‡¶º

// ‚úÖ Better: ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞‡¶ø data ‡¶∞‡¶æ‡¶ñ‡ßã
function createOptimized() {
  const hugeArray = new Array(1000000).fill("data");
  const firstElement = hugeArray[0]; // ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶è‡¶ü‡¶æ ‡¶∞‡¶æ‡¶ñ‡ßã

  return function () {
    console.log(firstElement);
  };
}
```

### Problem 3: Accidental Global Variables

```javascript
function problematic() {
  // ‚ùå 'use strict' ‡¶®‡¶æ ‡¶•‡¶æ‡¶ï‡¶≤‡ßá global variable ‡¶§‡ßà‡¶∞‡¶ø ‡¶π‡¶¨‡ßá
  count = 0; // var/let/const ‡¶®‡¶æ‡¶á!

  return function () {
    count++;
    return count;
  };
}

// ‚úÖ Always declare variables
function correct() {
  "use strict";
  let count = 0; // Proper declaration

  return function () {
    count++;
    return count;
  };
}
```

## Advanced Closure Concepts

### Concept 1: Closure Scope Chain

```javascript
const global = "Global";

function outer() {
  const outerVar = "Outer";

  function middle() {
    const middleVar = "Middle";

    function inner() {
      const innerVar = "Inner";

      console.log(innerVar); // Own scope
      console.log(middleVar); // Parent scope
      console.log(outerVar); // Grandparent scope
      console.log(global); // Global scope
    }

    return inner;
  }

  return middle;
}

const fn = outer()();
fn();
// "Inner"
// "Middle"
// "Outer"
// "Global"
```

### Concept 2: Multiple Closures Sharing Same Scope

```javascript
function createCounter() {
  let count = 0;

  const increment = function () {
    count++;
    return count;
  };

  const decrement = function () {
    count--;
    return count;
  };

  const getValue = function () {
    return count;
  };

  // ‡¶∏‡¶¨ functions same 'count' variable share ‡¶ï‡¶∞‡¶õ‡ßá
  return { increment, decrement, getValue };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.decrement()); // 1
console.log(counter.getValue()); // 1
```

### Concept 3: Closure with Parameters

```javascript
function greetGenerator(greeting) {
  return function (name) {
    return function (punctuation) {
      return `${greeting}, ${name}${punctuation}`;
    };
  };
}

const sayHello = greetGenerator("Hello");
const sayHelloToJohn = sayHello("John");

console.log(sayHelloToJohn("!")); // "Hello, John!"
console.log(sayHelloToJohn(".")); // "Hello, John."

// Or chain directly:
console.log(greetGenerator("Hi")("Jane")("?")); // "Hi, Jane?"
```

## Interview Questions & Answers

## üí¨ Interview Notes:

| ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®                         | ‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§ ‡¶â‡¶§‡ßç‡¶§‡¶∞                                                            |
| ------------------------------ | -------------------------------------------------------------------------- |
| Closure ‡¶ï‡ßÄ?                    | Function ‡¶è‡¶∞ ‡¶≠‡¶ø‡¶§‡¶∞ ‡¶•‡ßá‡¶ï‡ßá outer scope ‡¶è‡¶∞ variable access ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü ‡¶è‡¶Æ‡¶® behavior. |
| ‡¶ï‡ßá‡¶® ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞ ‡¶π‡ßü?                  | Data privacy, state maintain, async behavior handle ‡¶ï‡¶∞‡¶§‡ßá‡•§                  |
| Common use case ‡¶ï‡ßÄ?            | Counter, setTimeout, private variable, callback, React hooks (useState)‡•§   |
| Closure memory leak ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá? | ‡¶π‡ßç‡¶Ø‡¶æ‡¶Å, ‡¶Ø‡¶¶‡¶ø reference release ‡¶®‡¶æ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡•§                                    |
| Hoisting ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï?      | ‡¶®‡¶æ, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ scope chain ‡¶è‡¶∞ ‡¶â‡¶™‡¶∞ ‡¶®‡¶ø‡¶∞‡ßç‡¶≠‡¶∞‡¶∂‡ßÄ‡¶≤‡•§                                   |

---

## üéØ Summary:

- Closure = Function + its lexical scope.
- Inner function outer variable ‡¶Æ‡¶®‡ßá ‡¶∞‡¶æ‡¶ñ‡ßá‡•§
- Data hiding ‡¶ì state persistence ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¶‡¶æ‡¶∞‡ßÅ‡¶£ ‡¶ï‡¶æ‡¶∞‡ßç‡¶Ø‡¶ï‡¶∞‡•§

---

### ‡ßß. Closure ‡¶ï‡¶ø? Example ‡¶¶‡¶æ‡¶ì‡•§

**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
"Closure ‡¶π‡¶≤‡ßã ‡¶è‡¶ï‡¶ü‡¶ø function ‡¶Ø‡¶æ ‡¶§‡¶æ‡¶∞ outer function ‡¶è‡¶∞ variables ‡¶ï‡ßá access ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá, ‡¶è‡¶Æ‡¶®‡¶ï‡¶ø outer function execute ‡¶∂‡ßá‡¶∑ ‡¶π‡¶Ø‡¶º‡ßá ‡¶ó‡ßá‡¶≤‡ßá‡¶ì‡•§

```javascript
function outer() {
  const message = "Hello";

  return function inner() {
    console.log(message); // outer ‡¶è‡¶∞ variable access
  };
}

const fn = outer();
fn(); // 'Hello' - outer() ‡¶∂‡ßá‡¶∑ ‡¶π‡¶Ø‡¶º‡ßá ‡¶ó‡ßá‡¶≤‡ßá‡¶ì access ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶õ‡ßá
```

Closure ‡¶§‡ßà‡¶∞‡¶ø ‡¶π‡¶Ø‡¶º ‡¶ï‡¶æ‡¶∞‡¶£ inner function ‡¶§‡¶æ‡¶∞ lexical environment (outer ‡¶è‡¶∞ variables) remember ‡¶ï‡¶∞‡ßá ‡¶∞‡¶æ‡¶ñ‡ßá‡•§"

### ‡ß®. Closure ‡¶è‡¶∞ practical use cases ‡¶ï‡¶ø ‡¶ï‡¶ø?

**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
"Closure ‡¶è‡¶∞ main use cases:

1. **Data Privacy/Encapsulation:**

```javascript
function createAccount(balance) {
  return {
    getBalance: () => balance,
    deposit: (amount) => (balance += amount),
  };
}
```

2. **Function Factories:**

```javascript
const multiplyBy = (x) => (y) => x * y;
const double = multiplyBy(2);
```

3. **Event Handlers:** Loop ‡¶è unique values maintain ‡¶ï‡¶∞‡¶æ
4. **Memoization:** Results cache ‡¶ï‡¶∞‡¶æ performance ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø
5. **Module Pattern:** Private ‡¶è‡¶¨‡¶Ç public methods ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ"

### ‡ß©. ‡¶è‡¶á code ‡¶è‡¶∞ output ‡¶ï‡¶ø ‡¶π‡¶¨‡ßá ‡¶è‡¶¨‡¶Ç ‡¶ï‡ßá‡¶®?

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i);
  }, 1000);
}
```

**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
"Output: `3, 3, 3`

**Reason:**

- `var` function-scoped, ‡¶§‡¶æ‡¶á loop ‡¶è ‡¶è‡¶ï‡¶ü‡¶æ ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ `i` variable
- Loop ‡¶∂‡ßá‡¶∑‡ßá `i` = 3
- setTimeout execute ‡¶π‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º (1 second ‡¶™‡¶∞‡ßá) ‡¶∏‡¶¨ closure same `i` reference ‡¶ï‡¶∞‡ßá ‡¶Ø‡¶æ‡¶∞ value 3

**Solution:**

```javascript
// let ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßã (block-scoped)
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1000);
} // 0, 1, 2

// ‡¶Ö‡¶•‡¶¨‡¶æ IIFE
for (var i = 0; i < 3; i++) {
  (function (j) {
    setTimeout(() => console.log(j), 1000);
  })(i);
} // 0, 1, 2
```

"

### ‡ß™. ‡¶è‡¶á code ‡¶è ‡¶ï‡¶ø ‡¶π‡¶¨‡ßá?

```javascript
function createFunctions() {
  const funcs = [];

  for (var i = 0; i < 3; i++) {
    funcs.push(function () {
      return i;
    });
  }

  return funcs;
}

const functions = createFunctions();
console.log(functions[0]()); // ?
console.log(functions[1]()); // ?
console.log(functions[2]()); // ?
```

**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
"Output: `3, 3, 3`

‡¶∏‡¶¨ functions same `i` variable reference ‡¶ï‡¶∞‡¶õ‡ßá ‡¶Ø‡¶æ‡¶∞ final value 3‡•§

**Fix:**

```javascript
function createFunctions() {
  const funcs = [];

  for (let i = 0; i < 3; i++) {
    // var ‚Üí let
    funcs.push(function () {
      return i;
    });
  }

  return funcs;
}
// Output: 0, 1, 2
```

"

### ‡ß´. Closure ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá memory leak ‡¶π‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá?

**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
"Closure ‡¶è referenced variables garbage collect ‡¶π‡¶Ø‡¶º ‡¶®‡¶æ, ‡¶§‡¶æ‡¶á ‡¶¨‡¶°‡¶º objects/arrays closure ‡¶è ‡¶∞‡¶æ‡¶ñ‡¶≤‡ßá memory waste ‡¶π‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡•§

```javascript
// ‚ùå Problem
function createClosure() {
  const hugeArray = new Array(1000000).fill("data");

  return function () {
    console.log(hugeArray.length); // Entire array in memory!
  };
}

// ‚úÖ Solution: ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞‡¶ø data ‡¶∞‡¶æ‡¶ñ‡ßã
function createClosure() {
  const hugeArray = new Array(1000000).fill("data");
  const length = hugeArray.length; // ‡¶∂‡ßÅ‡¶ß‡ßÅ length store ‡¶ï‡¶∞‡ßã

  return function () {
    console.log(length);
  };
}
```

Best practice: Closures ‡¶è minimum necessary data ‡¶∞‡¶æ‡¶ñ‡ßã‡•§"

### ‡ß¨. ‡¶è‡¶á code ‡¶è‡¶∞ output ‡¶ï‡¶ø?

```javascript
function outer() {
  let count = 0;

  return {
    increment: function () {
      count++;
    },
    getCount: function () {
      return count;
    },
  };
}

const counter1 = outer();
const counter2 = outer();

counter1.increment();
counter1.increment();
counter2.increment();

console.log(counter1.getCount());
console.log(counter2.getCount());
```

**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
"Output:

```
2
1
```

**Explanation:**

- ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶æ `outer()` call ‡¶®‡¶§‡ßÅ‡¶® execution context ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá
- ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶æ context ‡¶è‡¶∞ ‡¶®‡¶ø‡¶ú‡¶∏‡ßç‡¶¨ `count` variable ‡¶Ü‡¶õ‡ßá
- `counter1` ‡¶è‡¶¨‡¶Ç `counter2` ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ closures, ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ `count`
- ‡¶§‡¶æ‡¶á counter1 ‡¶è‡¶∞ count = 2, counter2 ‡¶è‡¶∞ count = 1"

### ‡ß≠. Lexical scoping ‡¶ï‡¶ø ‡¶è‡¶¨‡¶Ç closure ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá relation?

**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
"**Lexical Scoping** ‡¶Æ‡¶æ‡¶®‡ßá function ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá define ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá, ‡¶∏‡ßá‡¶ñ‡¶æ‡¶®‡¶ï‡¶æ‡¶∞ scope access ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡•§

```javascript
const name = "Global";

function outer() {
  const name = "Outer";

  function inner() {
    console.log(name); // 'Outer' (lexically parent ‡¶è‡¶∞)
  }

  inner();
}
```

Closure ‡¶π‡¶≤‡ßã lexical scoping ‡¶è‡¶∞ consequence‡•§ Inner function ‡¶§‡¶æ‡¶∞ lexical environment (parent variables) remember ‡¶ï‡¶∞‡ßá ‡¶∞‡¶æ‡¶ñ‡ßá, ‡¶è‡¶Æ‡¶®‡¶ï‡¶ø parent function ‡¶∂‡ßá‡¶∑ ‡¶π‡¶≤‡ßá‡¶ì‡•§ ‡¶è‡¶≠‡¶æ‡¶¨‡ßá closure ‡¶§‡ßà‡¶∞‡¶ø ‡¶π‡¶Ø‡¶º‡•§"

## Visual Representation

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         CLOSURE VISUALIZATION          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                        ‚îÇ
‚îÇ  function outer() {                    ‚îÇ
‚îÇ    const secret = "Hidden"; ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ
‚îÇ                                 ‚îÇ      ‚îÇ
‚îÇ    return function inner() {    ‚îÇ      ‚îÇ
‚îÇ      console.log(secret); ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ
‚îÇ    }                        Closure!   ‚îÇ
‚îÇ  }                                     ‚îÇ
‚îÇ                                        ‚îÇ
‚îÇ  Inner function "closes over"          ‚îÇ
‚îÇ  outer function's variables            ‚îÇ
‚îÇ                                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Key Takeaways

1. ‚úÖ **Closure = Function + Lexical Environment**
2. ‚úÖ **Variables ‡¶ï‡ßá outer function ‡¶∂‡ßá‡¶∑ ‡¶π‡¶≤‡ßá‡¶ì access ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º**
3. ‚úÖ **Data privacy/encapsulation ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø perfect**
4. ‚úÖ **Loop ‡¶è `let` ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßã, `var` ‡¶®‡¶æ**
5. ‚úÖ **Memory efficient ‡¶π‡¶ì - ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞‡¶ø data closure ‡¶è ‡¶∞‡¶æ‡¶ñ‡ßã**
6. ‚úÖ **Every function in JavaScript creates a closure**
7. ‚úÖ **Closure scope chain follow ‡¶ï‡¶∞‡ßá**

## Practice Exercise

‡¶è‡¶á function implement ‡¶ï‡¶∞‡ßã:

```javascript
// TODO: Implement a function that creates a password validator
// Requirements:
// - Minimum length check
// - Maximum attempts tracking
// - Lock after 3 failed attempts
// - Success unlocks

function createPasswordValidator(correctPassword) {
  // Your code here
}

const validator = createPasswordValidator("secret123");
validator.validate("wrong"); // false, 2 attempts left
validator.validate("wrong"); // false, 1 attempt left
validator.validate("secret123"); // true, unlocked
```

Closure practice ‡¶ï‡¶∞‡¶æ‡¶∞ best way ‡¶π‡¶≤‡ßã ‡¶®‡¶ø‡¶ú‡ßá code ‡¶≤‡¶ø‡¶ñ‡ßá test ‡¶ï‡¶∞‡¶æ! üöÄ
