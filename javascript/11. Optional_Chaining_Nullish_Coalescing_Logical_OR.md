# Optional Chaining (?.), Nullish Coalescing (??), Logical OR (||) - সম্পূর্ণ গাইড

## Table of Contents

1. Optional Chaining (?.)
2. Nullish Coalescing (??)
3. Logical OR (||)
4. তুলনা এবং পার্থক্য
5. Real-world Examples
6. Common Mistakes
7. Interview Questions

---

## 1. OPTIONAL CHAINING (?.)

Optional chaining একটি safe way to access nested object properties, এমনকি যদি intermediate property না থাকে।

### Problem Without Optional Chaining

```javascript
const user = {
  name: "John",
  address: {
    city: "Dhaka",
  },
};

// ❌ Unsafe - Error হবে যদি address না থাকে
// console.log(user.address.city); // Works
// console.log(user.contact.email); // TypeError: Cannot read property 'email' of undefined

// ❌ Old way - Verbose checking
if (user && user.address && user.address.city) {
  console.log(user.address.city);
}

if (user && user.contact && user.contact.email) {
  console.log(user.contact.email);
}
```

### Solution With Optional Chaining

```javascript
const user = {
  name: "John",
  address: {
    city: "Dhaka",
  },
};

// ✅ Safe - No error, returns undefined
console.log(user?.address?.city); // "Dhaka"
console.log(user?.contact?.email); // undefined (no error!)
console.log(user?.profile?.avatar?.url); // undefined
```

### কিভাবে কাজ করে?

```javascript
// user?.address?.city এর flow:

// Step 1: user আছে কিনা check করে
//   - যদি null/undefined হয়, immediately undefined return করে
//   - নাহলে next step

// Step 2: user.address আছে কিনা check করে
//   - যদি null/undefined হয়, undefined return করে
//   - নাহলে next step

// Step 3: user.address.city return করে
```

### Optional Chaining with Objects

```javascript
const user = {
  name: "John",
  age: 25,
  address: {
    city: "Dhaka",
    location: {
      lat: 23.8103,
      lng: 90.4125,
    },
  },
};

// Deep nesting
console.log(user?.address?.location?.lat); // 23.8103
console.log(user?.address?.location?.country); // undefined
console.log(user?.contact?.phone?.mobile); // undefined

// Without optional chaining - would need:
const lat =
  user && user.address && user.address.location && user.address.location.lat;
```

### Optional Chaining with Arrays

```javascript
const users = [
  { name: "John", age: 25 },
  { name: "Jane", age: 30 },
];

// ✅ Safe array access
console.log(users?.[0]?.name); // "John"
console.log(users?.[2]?.name); // undefined (no error!)
console.log(users?.[0]?.address?.city); // undefined

// Empty/null/undefined arrays
const emptyArray = null;
console.log(emptyArray?.[0]); // undefined (no error!)

// Nested arrays
const data = {
  users: [{ name: "John", posts: [{ title: "Post 1" }] }],
};

console.log(data?.users?.[0]?.posts?.[0]?.title); // "Post 1"
console.log(data?.users?.[1]?.posts?.[0]?.title); // undefined
```

### Optional Chaining with Functions

```javascript
const user = {
  name: "John",
  greet: function () {
    return `Hello, ${this.name}`;
  },
};

// ✅ Safe function call
console.log(user.greet?.()); // "Hello, John"
console.log(user.farewell?.()); // undefined (function doesn't exist)

// API calls
const api = {
  getData: () => ({ data: "Some data" }),
};

console.log(api.getData?.()); // { data: "Some data" }
console.log(api.postData?.()); // undefined

// Callback functions
function processData(callback) {
  const result = "Processed";
  callback?.(result); // Only calls if callback exists
}

processData((data) => console.log(data)); // "Processed"
processData(); // No error!
```

### Optional Chaining with Methods

```javascript
const calculator = {
  add: (a, b) => a + b,
  subtract: (a, b) => a - b,
};

// ✅ Safe method calls
console.log(calculator.add?.(5, 3)); // 8
console.log(calculator.multiply?.(5, 3)); // undefined

// DOM manipulation
const element = document.querySelector("#myElement");
element?.classList?.add("active"); // Safe even if element not found

// Event listeners
button?.addEventListener?.("click", handleClick); // Safe
```

### Optional Chaining with Dynamic Properties

```javascript
const user = {
  name: "John",
  age: 25,
};

const key = "address";

// Dynamic property access
console.log(user?.[key]?.city); // undefined
console.log(user?.["name"]); // "John"

// Computed property names
const propName = "contact";
console.log(user?.[propName]?.email); // undefined
```

### Combining with Other Operators

```javascript
const user = {
  name: "John",
  address: {
    city: "Dhaka",
  },
};

// With Nullish Coalescing
const city = user?.address?.city ?? "Unknown City";
console.log(city); // "Dhaka"

const country = user?.address?.country ?? "Unknown Country";
console.log(country); // "Unknown Country"

// With Logical OR
const email = user?.contact?.email || "no-email@example.com";
console.log(email); // "no-email@example.com"

// With ternary
const greeting = user?.name ? `Hello, ${user.name}` : "Hello, Guest";
console.log(greeting); // "Hello, John"
```

---

## 2. NULLISH COALESCING (??)

Nullish Coalescing operator শুধুমাত্র `null` বা `undefined` এর জন্য default value return করে।

### Basic Usage

```javascript
// Syntax: leftValue ?? rightValue

const value1 = null ?? "default";
console.log(value1); // "default"

const value2 = undefined ?? "default";
console.log(value2); // "default"

const value3 = "actual value" ?? "default";
console.log(value3); // "actual value"

const value4 = 0 ?? "default";
console.log(value4); // 0 (not "default"!)

const value5 = "" ?? "default";
console.log(value5); // "" (not "default"!)

const value6 = false ?? "default";
console.log(value6); // false (not "default"!)
```

### কখন ব্যবহার করবে?

```javascript
// User settings যেখানে 0, false, "" valid values
const settings = {
  volume: 0, // 0 is valid
  darkMode: false, // false is valid
  username: "", // empty string might be valid
  notifications: null, // null means not set
};

// ✅ Nullish Coalescing - শুধু null/undefined handle করে
const volume = settings.volume ?? 50;
console.log(volume); // 0 (not 50, because 0 is valid)

const darkMode = settings.darkMode ?? true;
console.log(darkMode); // false (not true)

const notifications = settings.notifications ?? true;
console.log(notifications); // true (because it's null)

// ❌ Logical OR - 0, false, "" কেও replace করে দেয়
const volume2 = settings.volume || 50;
console.log(volume2); // 50 (Wrong! 0 was replaced)
```

### Function Parameters with Default Values

```javascript
function createUser(name, age, email) {
  // ✅ Good - handles null/undefined
  const userName = name ?? "Guest";
  const userAge = age ?? 18;
  const userEmail = email ?? "no-email@example.com";

  return { userName, userAge, userEmail };
}

console.log(createUser("John", 0, ""));
// {
//   userName: "John",
//   userAge: 0,        ✅ 0 preserved
//   userEmail: ""      ✅ empty string preserved
// }

console.log(createUser(null, null, null));
// {
//   userName: "Guest",
//   userAge: 18,
//   userEmail: "no-email@example.com"
// }
```

### API Response Handling

```javascript
const apiResponse = {
  data: {
    count: 0, // Valid data
    message: "", // Valid empty message
    isActive: false, // Valid boolean
    user: null, // No user data
  },
};

// ✅ Correct handling
const count = apiResponse.data.count ?? 10;
console.log(count); // 0 (actual value)

const message = apiResponse.data.message ?? "No message";
console.log(message); // "" (actual empty string)

const isActive = apiResponse.data.isActive ?? true;
console.log(isActive); // false (actual value)

const user = apiResponse.data.user ?? { name: "Guest" };
console.log(user); // { name: "Guest" }
```

### Chaining Nullish Coalescing

```javascript
const config = {
  primary: null,
  secondary: undefined,
  tertiary: "value",
};

// Chain multiple fallbacks
const value =
  config.primary ?? config.secondary ?? config.tertiary ?? "default";
console.log(value); // "value"

// Real example: Get value from multiple sources
const getUserPreference = (user) => {
  return (
    user?.settings?.theme ??
    user?.profile?.defaultTheme ??
    localStorage.getItem("theme") ??
    "light"
  );
};
```

### With Optional Chaining

```javascript
const user = {
  name: "John",
  settings: {
    notifications: null,
  },
};

// Perfect combination
const theme = user?.settings?.theme ?? "light";
console.log(theme); // "light"

const notifications = user?.settings?.notifications ?? true;
console.log(notifications); // true

const language = user?.preferences?.language ?? "en";
console.log(language); // "en"
```

---

## 3. LOGICAL OR (||)

Logical OR সব falsy values (`false`, `0`, `""`, `null`, `undefined`, `NaN`) এর জন্য default value return করে।

### Falsy Values in JavaScript

```javascript
// All falsy values:
false
0
-0
0n (BigInt zero)
"" (empty string)
null
undefined
NaN

// Everything else is truthy
```

### Basic Usage

```javascript
const value1 = false || "default";
console.log(value1); // "default"

const value2 = 0 || "default";
console.log(value2); // "default"

const value3 = "" || "default";
console.log(value3); // "default"

const value4 = null || "default";
console.log(value4); // "default"

const value5 = undefined || "default";
console.log(value5); // "default"

const value6 = "actual value" || "default";
console.log(value6); // "actual value"
```

### Common Use Cases

#### 1. Default Function Parameters (Old way)

```javascript
// Before ES6 default parameters
function greet(name) {
  name = name || "Guest";
  console.log(`Hello, ${name}`);
}

greet("John"); // "Hello, John"
greet(); // "Hello, Guest"
greet(""); // "Hello, Guest" (empty string treated as falsy)

// ⚠️ Problem: Can't pass 0, false, or ""
function setVolume(level) {
  level = level || 50;
  console.log(`Volume: ${level}`);
}

setVolume(0); // "Volume: 50" (Wrong! 0 was intended)
setVolume(30); // "Volume: 30"
```

#### 2. Short-circuit Evaluation

```javascript
// Execute code only if condition is truthy
const isLoggedIn = true;

isLoggedIn || console.log("Please log in"); // Nothing logged
!isLoggedIn || console.log("Welcome!"); // "Welcome!"

// Assign value conditionally
let message;
const error = "Something went wrong";
message = error || "No error";
console.log(message); // "Something went wrong"
```

#### 3. Multiple Fallbacks

```javascript
const config = {
  userTheme: "",
  browserTheme: null,
  defaultTheme: "light",
};

const theme =
  config.userTheme || config.browserTheme || config.defaultTheme || "dark";
console.log(theme); // "light" (first truthy value)
```

#### 4. Conditional Rendering (React-like)

```javascript
const showWelcome = true;
const userName = "John";

// Show message if condition is truthy
const message = showWelcome && `Welcome, ${userName}!`;
console.log(message); // "Welcome, John!"

// Show default if no user
const greeting = userName || "Guest";
console.log(greeting); // "John"
```

---

## 4. তুলনা এবং পার্থক্য

### || vs ?? Comparison

```javascript
// Test with different values
const testValues = [
  { value: null, name: "null" },
  { value: undefined, name: "undefined" },
  { value: 0, name: "0" },
  { value: false, name: "false" },
  { value: "", name: "empty string" },
  { value: "value", name: "actual value" },
];

console.log("Value".padEnd(20) + "|| 'default'".padEnd(20) + "?? 'default'");
console.log("-".repeat(60));

testValues.forEach(({ value, name }) => {
  const withOR = value || "default";
  const withNullish = value ?? "default";

  console.log(
    name.padEnd(20) + String(withOR).padEnd(20) + String(withNullish)
  );
});

// Output:
// Value               || 'default'       ?? 'default'
// ------------------------------------------------------------
// null                default             default
// undefined           default             default
// 0                   default             0          ⭐
// false               default             false      ⭐
// empty string        default                        ⭐
// actual value        value               value
```

### Detailed Comparison Table

| Value       | `value \|\| "default"` | `value ?? "default"` | Best Use                        |
| ----------- | ---------------------- | -------------------- | ------------------------------- |
| `null`      | `"default"`            | `"default"`          | Both work                       |
| `undefined` | `"default"`            | `"default"`          | Both work                       |
| `0`         | `"default"` ❌         | `0` ✅               | `??` when 0 is valid            |
| `false`     | `"default"` ❌         | `false` ✅           | `??` when false is valid        |
| `""`        | `"default"` ❌         | `""` ✅              | `??` when empty string is valid |
| `NaN`       | `"default"`            | `NaN`                | Depends on context              |
| `"value"`   | `"value"`              | `"value"`            | Both work                       |

### When to Use Which?

```javascript
// ✅ Use ?? when:
// - 0, false, "" are valid values
// - Working with numbers, booleans, or strings

const volume = userSettings.volume ?? 50; // 0 is valid
const autoSave = userSettings.autoSave ?? true; // false is valid
const username = userSettings.username ?? "Guest"; // "" might be valid

// ✅ Use || when:
// - You want to filter out all falsy values
// - 0, false, "" should be replaced with default

const displayName = user.nickname || user.fullName || "Anonymous";
const searchQuery = urlParams.q || localStorage.getItem("lastQuery") || "";

// ✅ Use ?. when:
// - Accessing nested properties that might not exist
// - Preventing TypeError

const city = user?.address?.city;
const firstPost = user?.posts?.[0]?.title;
api.getData?.();
```

---

## 5. REAL-WORLD EXAMPLES

### Example 1: User Profile Display

```javascript
const user = {
  name: "John Doe",
  profile: {
    avatar: null,
    bio: "",
    age: 0,
    isVerified: false,
  },
  settings: {
    theme: undefined,
    notifications: null,
  },
};

// ❌ Wrong - Using || replaces valid values
const age1 = user?.profile?.age || 18;
console.log(age1); // 18 (Wrong! Age is 0, which is valid)

const bio1 = user?.profile?.bio || "No bio available";
console.log(bio1); // "No bio available" (Wrong! Empty bio might be intentional)

// ✅ Correct - Using ?? preserves valid values
const age2 = user?.profile?.age ?? 18;
console.log(age2); // 0 (Correct!)

const bio2 = user?.profile?.bio ?? "No bio available";
console.log(bio2); // "" (Correct! Empty string preserved)

const avatar = user?.profile?.avatar ?? "/default-avatar.png";
console.log(avatar); // "/default-avatar.png"

const theme = user?.settings?.theme ?? "light";
console.log(theme); // "light"

const isVerified = user?.profile?.isVerified ?? false;
console.log(isVerified); // false (actual value, not default)
```

### Example 2: API Configuration

```javascript
function createApiClient(config) {
  const defaults = {
    baseURL: "https://api.example.com",
    timeout: 5000,
    retries: 3,
    cache: true,
  };

  // ✅ Using ?? to merge configs
  return {
    baseURL: config?.baseURL ?? defaults.baseURL,
    timeout: config?.timeout ?? defaults.timeout,
    retries: config?.retries ?? defaults.retries,
    cache: config?.cache ?? defaults.cache,
    headers: config?.headers ?? {},
  };
}

// Test cases
const client1 = createApiClient({
  timeout: 0, // Valid: no timeout
  cache: false, // Valid: disable cache
  retries: 0, // Valid: no retries
});

console.log(client1);
// {
//   baseURL: "https://api.example.com",
//   timeout: 0,     ✅ Preserved
//   retries: 0,     ✅ Preserved
//   cache: false,   ✅ Preserved
//   headers: {}
// }

const client2 = createApiClient({});
console.log(client2);
// All defaults applied
```

### Example 3: Form Validation

```javascript
function validateForm(formData) {
  const errors = {};

  // Name validation
  const name = formData?.name?.trim() ?? "";
  if (!name) {
    errors.name = "Name is required";
  }

  // Age validation (0 is valid)
  const age = formData?.age ?? null;
  if (age === null) {
    errors.age = "Age is required";
  } else if (age < 0) {
    errors.age = "Age must be positive";
  }

  // Email validation (empty string is invalid)
  const email = formData?.email?.trim() || null;
  if (!email) {
    errors.email = "Email is required";
  } else if (!email.includes("@")) {
    errors.email = "Invalid email";
  }

  // Accept terms (false is valid answer)
  const acceptTerms = formData?.acceptTerms ?? null;
  if (acceptTerms === null) {
    errors.acceptTerms = "You must accept or decline terms";
  }

  return {
    isValid: Object.keys(errors).length === 0,
    errors,
  };
}

// Test
const result1 = validateForm({
  name: "John",
  age: 0,
  email: "john@example.com",
  acceptTerms: false,
});
console.log(result1);
// { isValid: true, errors: {} }

const result2 = validateForm({
  name: "",
  age: null,
  email: "",
  acceptTerms: undefined,
});
console.log(result2);
// {
//   isValid: false,
//   errors: {
//     name: "Name is required",
//     age: "Age is required",
//     email: "Email is required",
//     acceptTerms: "You must accept or decline terms"
//   }
// }
```

### Example 4: Shopping Cart with Discounts

```javascript
const cart = {
  items: [
    { id: 1, name: "Laptop", price: 50000, quantity: 1, discount: 0 },
    { id: 2, name: "Mouse", price: 500, quantity: 2, discount: null },
    { id: 3, name: "Keyboard", price: 1500, quantity: 1, discount: 10 },
  ],
  coupon: {
    code: "",
    discount: false,
  },
};

function calculateTotal(cart) {
  let subtotal = 0;

  cart?.items?.forEach((item) => {
    const price = item?.price ?? 0;
    const quantity = item?.quantity ?? 1;
    const discount = item?.discount ?? 0; // 0% discount is valid

    const itemTotal = price * quantity;
    const discountAmount = (itemTotal * discount) / 100;
    subtotal += itemTotal - discountAmount;

    console.log(`${item.name}: ৳${itemTotal} - ৳${discountAmount} discount`);
  });

  // Coupon discount (false means no coupon, not invalid)
  const couponDiscount = cart?.coupon?.discount ?? 0;
  const couponAmount = (subtotal * couponDiscount) / 100;

  const total = subtotal - couponAmount;

  return {
    subtotal,
    couponDiscount: couponAmount,
    total,
  };
}

const result = calculateTotal(cart);
console.log(result);
// Laptop: ৳50000 - ৳0 discount    ✅ 0% preserved
// Mouse: ৳1000 - ৳0 discount      ✅ null → 0%
// Keyboard: ৳1500 - ৳150 discount
```

### Example 5: Local Storage with Fallbacks

```javascript
const storage = {
  get(key, defaultValue = null) {
    try {
      const item = localStorage.getItem(key);

      // item can be "0", "false", "" which are valid
      // null means key doesn't exist
      if (item === null) {
        return defaultValue;
      }

      // Try to parse JSON
      try {
        return JSON.parse(item);
      } catch {
        return item; // Return as string
      }
    } catch (error) {
      console.error("Storage error:", error);
      return defaultValue;
    }
  },

  set(key, value) {
    try {
      const item = typeof value === "string" ? value : JSON.stringify(value);
      localStorage.setItem(key, item);
      return true;
    } catch (error) {
      console.error("Storage error:", error);
      return false;
    }
  },
};

// Usage
storage.set("volume", 0);
storage.set("darkMode", false);
storage.set("username", "");
storage.set("user", { name: "John" });

// ✅ Correct retrieval
const volume = storage.get("volume", 50);
console.log(volume); // 0 (not 50!)

const darkMode = storage.get("darkMode", true);
console.log(darkMode); // false (not true!)

const username = storage.get("username", "Guest");
console.log(username); // "" (not 'Guest'!)

const language = storage.get("language", "en");
console.log(language); // 'en' (key doesn't exist)
```

### Example 6: Deep Object Access with Fallbacks

```javascript
const data = {
  user: {
    profile: {
      personal: {
        name: "John",
        age: 0,
        contact: {
          email: "",
          phone: null,
        },
      },
      preferences: {
        notifications: false,
        theme: undefined,
      },
    },
  },
};

// Safe deep access with appropriate defaults
const name = data?.user?.profile?.personal?.name ?? "Guest";
console.log(name); // "John"

const age = data?.user?.profile?.personal?.age ?? 18;
console.log(age); // 0 ✅

const email = data?.user?.profile?.personal?.contact?.email ?? "no-email";
console.log(email); // "" ✅

const phone = data?.user?.profile?.personal?.contact?.phone ?? "no-phone";
console.log(phone); // "no-phone"

const notifications = data?.user?.profile?.preferences?.notifications ?? true;
console.log(notifications); // false ✅

const theme = data?.user?.profile?.preferences?.theme ?? "light";
console.log(theme); // "light"

// Non-existent path
const avatar = data?.user?.profile?.personal?.avatar?.url ?? "/default.png";
console.log(avatar); // "/default.png"
```

---

## 6. COMMON MISTAKES

### Mistake 1: Using || when ?? is needed

```javascript
function setConfig(userConfig) {
  // ❌ Wrong - replaces valid 0, false, ""
  return {
    port: userConfig.port || 3000, // Problem if port is 0
    debug: userConfig.debug || false, // Problem if debug is false
    prefix: userConfig.prefix || "/api", // Problem if prefix is ""
  };
}

// ✅ Correct
function setConfigCorrect(userConfig) {
  return {
    port: userConfig.port ?? 3000,
    debug: userConfig.debug ?? false,
    prefix: userConfig.prefix ?? "/api",
  };
}

// Test
console.log(setConfig({ port: 0, debug: false, prefix: "" }));
// { port: 3000, debug: false, prefix: "/api" } ❌ Wrong!

console.log(setConfigCorrect({ port: 0, debug: false, prefix: "" }));
// { port: 0, debug: false, prefix: "" } ✅ Correct!
```

### Mistake 2: Forgetting Optional Chaining

```javascript
const user = null;

// ❌ Error
// const name = user.profile.name ?? "Guest"; // TypeError!

// ✅ Correct
const name = user?.profile?.name ?? "Guest";
console.log(name); // "Guest"
```

### Mistake 3: Mixing || and ?? incorrectly

```javascript
// ❌ SyntaxError - can't mix without parentheses
// const value = null || undefined ?? "default";

// ✅ Use parentheses
const value1 = (null || undefined) ?? "default";
const value2 = null || (undefined ?? "default");

// Better: Be explicit about what you want
const value3 = null ?? undefined ?? "default";
console.log(value3); // "default"
```

### Mistake 4: Not Handling Arrays Properly

```javascript
const data = {
  users: [],
};

// ❌ Wrong - empty array is truthy
const users1 = data.users || ["default"];
console.log(users1); // [] (not ["default"])

// ✅ Check length explicitly
const users2 = data.users?.length > 0 ? data.users : ["default"];
console.log(users2); // ["default"]

// Or check for null/undefined only
const users3 = data.users ?? ["default"];
console.log(users3); // [] (empty array is valid!)
```

### Mistake 5: Short-circuit Side Effects

```javascript
let count = 0;

function increment() {
  count++;
  return count;
}

// ❌ Unexpected behavior
const result1 = true || increment();
console.log(result1); // true
console.log(count); // 0 (increment not called!)

// ❌ Unexpected behavior
const result2 = false && increment();
console.log(result2); // false
console.log(count); // 0 (increment not called!)

// ✅ Be explicit if you need side effects
let result3;
if (!result3) {
  result3 = increment();
}
```

---

## 7. INTERVIEW QUESTIONS & ANSWERS

### ১. Optional Chaining (?.) কি এবং কেন ব্যবহার করা হয়?

**উত্তর:**
"Optional Chaining (`?.`) একটি safe way to access nested object properties। যদি intermediate property null বা undefined হয়, তাহলে error throw না করে undefined return করে।

```javascript
const user = {
  name: "John",
  address: { city: "Dhaka" },
};

// Without optional chaining
if (user && user.address && user.address.city) {
  console.log(user.address.city);
}

// With optional chaining
console.log(user?.address?.city); // "Dhaka"
console.log(user?.contact?.email); // undefined (no error!)
```

**Benefits:**

- Cleaner code
- No TypeError
- Shorter syntax
- Works with objects, arrays, and functions"

### ২. Nullish Coalescing (??) এবং Logical OR (||) এর পার্থক্য কি?

**উত্তর:**

```javascript
const value = 0;

// || returns right side for ALL falsy values
console.log(value || 10); // 10 (0 is falsy)

// ?? returns right side ONLY for null/undefined
console.log(value ?? 10); // 0 (0 is not null/undefined)
```

**Key Differences:**

| Operator | Replaces                                                          | Use When                            |
| -------- | ----------------------------------------------------------------- | ----------------------------------- |
| `\|\|`   | All falsy values (`false`, `0`, `""`, `null`, `undefined`, `NaN`) | Want to filter falsy values         |
| `??`     | Only `null` and `undefined`                                       | `0`, `false`, `""` are valid values |

**Example:**

```javascript
const settings = {
  volume: 0, // 0 is valid
  muted: false, // false is valid
};

// ❌ Wrong
const vol1 = settings.volume || 50; // 50 (Wrong!)

// ✅ Correct
const vol2 = settings.volume ?? 50; // 0 (Correct!)
```

"

### ৩. এই code এর output কি?

```javascript
const user = {
  name: "",
  age: 0,
  active: false,
};

console.log(user.name || "Guest");
console.log(user.name ?? "Guest");
console.log(user.age ?? 18);
console.log(user.active || true);
console.log(user.active ?? true);
```

**উত্তর:**

```javascript
"Guest"; // "" is falsy, || returns "Guest"
""; // "" is not null/undefined, ?? returns ""
18; // 0 is falsy, || returns 18
0; // 0 is not null/undefined, ?? returns 0
true; // false is falsy, || returns true
false; // false is not null/undefined, ?? returns false
```

**Explanation:**

- `||` সব falsy values (`""`, `0`, `false`) কে replace করে
- `??` শুধু `null` এবং `undefined` replace করে
- `""`, `0`, `false` valid values হিসেবে preserve হয় `??` এ"

### ৪. Optional chaining কি শুধু objects এর জন্য?

**উত্তর:**
"না! Optional chaining তিনটি ক্ষেত্রে ব্যবহার করা যায়:

**1. Objects:**

```javascript
const user = { name: "John" };
console.log(user?.address?.city); // undefined
```

**2. Arrays:**

```javascript
const users = [{ name: "John" }];
console.log(users?.[0]?.name); // "John"
console.log(users?.[5]?.name); // undefined
```

**3. Functions:**

```javascript
const obj = {
  greet: () => "Hello",
};
console.log(obj.greet?.()); // "Hello"
console.log(obj.farewell?.()); // undefined
```

**Combined:**

```javascript
const data = {
  users: [{ getName: () => "John" }],
};
console.log(data?.users?.[0]?.getName?.()); // "John"
```

"

### ৫. এই code এ কি হবে?

```javascript
const obj = {
  value: 0,
};

const result = obj?.value ?? 10;
console.log(result);
```

**উত্তর:**

```javascript
0;
```

**Explanation:**

1. `obj?.value` → `0` (object আছে, value আছে)
2. `0 ?? 10` → `0` (0 is not null/undefined)
3. Final result: `0`

**Step by step:**

```javascript
obj?.value; // Step 1: 0
0 ?? 10; // Step 2: 0 (not null/undefined)
result = 0; // Final
```

"

### ৬. কখন || use করবে এবং কখন ?? use করবে?

**উত্তর:**
"**Use `??` when:**

- Numbers যেখানে 0 valid (volume, count, index)
- Booleans যেখানে false valid (flags, toggles)
- Strings যেখানে empty string valid (search, input)

```javascript
const settings = {
  volume: 0, // Use ??
  notifications: false, // Use ??
  username: "", // Use ??
};

const volume = settings.volume ?? 50;
const notify = settings.notifications ?? true;
const name = settings.username ?? "Guest";
```

**Use `||` when:**

- চাও সব falsy values filter করতে
- Empty strings, 0, false কে invalid মনে করো

```javascript
const input = {
  search: "",
  page: 0,
};

// Want non-empty search only
const query = input.search || "default search";

// Want page 1 instead of 0
const pageNum = input.page || 1;
```

**Best Practice:**

```javascript
// ✅ Good
const port = config.port ?? 3000; // 0 is valid port
const debug = config.debug ?? false; // false is valid
const name = input.trim() || "Anonymous"; // empty invalid

// ❌ Avoid
const port = config.port || 3000; // Wrong if port is 0
const name = input ?? "Anonymous"; // Wrong if empty string
```

"

### ৭. এই pattern কি করে?

```javascript
const data = (await api.getData?.()) ?? [];
```

**উত্তর:**
"এটি তিনটি safety mechanism combine করছে:

**Breakdown:**

```javascript
// 1. Optional chaining on function
api.getData?.(); // Call only if exists, else undefined

// 2. Await the promise
await api.getData?.(); // Wait for result

// 3. Nullish coalescing for default
(await api.getData?.()) ?? []; // Return [] if null/undefined
```

**Step by step:**

```javascript
// If api.getData exists and returns data:
await api.getData?.() → [data] → [data]

// If api.getData exists but returns null:
await api.getData?.() → null → []

// If api.getData doesn't exist:
api.getData?.() → undefined → []
```

**Real example:**

```javascript
// Without safety
const users = await api.getUsers(); // Error if api undefined!

// With safety
const users = (await api.getUsers?.()) ?? [];
```

এটি defensive programming এর একটি excellent example।"

### ৮. এই code এর problem কি?

```javascript
const value = null || undefined ?? "default";
```

**উত্তর:**
"**SyntaxError!** `||` এবং `??` একসাথে mix করা যায় না parentheses ছাড়া।

**Why?**
JavaScript ambiguity avoid করতে চায়:

```javascript
// Unclear precedence
null || undefined ?? "default"
// Could mean:
(null || undefined) ?? "default"  // ?
null || (undefined ?? "default")  // ?
```

**Solution:**

```javascript
// ✅ Use parentheses
const value1 = (null || undefined) ?? "default";
const value2 = null || (undefined ?? "default");

// ✅ Or be explicit
const value3 = null ?? undefined ?? "default"; // OK
const value4 = null || undefined || "default"; // OK
```

**Best Practice:**

```javascript
// Choose one operator based on needs
const value = null ?? "default"; // Nullish only
const value = null || "default"; // Falsy values
```

"

### ৯. Optional chaining এর performance impact আছে?

**উত্তর:**
"**Minimal performance impact**, কিন্তু benefits অনেক বেশি।

**Performance:**

```javascript
// Traditional checking
if (obj && obj.prop && obj.prop.nested) {
  // 3 checks
}

// Optional chaining
obj?.prop?.nested;
// Same 3 checks, but optimized by engine
```

Modern JavaScript engines optional chaining optimize করে।

**Real impact:**

```javascript
// Millions of iterations
console.time("traditional");
for (let i = 0; i < 1000000; i++) {
  const val = obj && obj.a && obj.a.b;
}
console.timeEnd("traditional");

console.time("optional chaining");
for (let i = 0; i < 1000000; i++) {
  const val = obj?.a?.b;
}
console.timeEnd("optional chaining");

// Difference: Negligible (< 1ms typically)
```

**Benefits outweigh cost:**

- Cleaner code
- Fewer bugs
- Better readability
- Easier maintenance

**Conclusion:** Performance concern না করে freely use করো।"

### ১০. এই code কি return করবে?

```javascript
const arr = [];
const result = arr[0]?.name ?? "default";
console.log(result);
```

**উত্তর:**

```javascript
"default";
```

**Step by step:**

```javascript
arr[0]; // undefined (array empty)
arr[0]?.name; // undefined (short-circuit)
undefined ?? "default"; // "default"
```

**Compare with:**

```javascript
const arr = [{ name: "" }];
const result = arr[0]?.name ?? "default";
console.log(result); // "" (empty string preserved)

const arr = [{ age: 0 }];
const result = arr[0]?.name ?? "default";
console.log(result); // "default" (property doesn't exist)
```

"

---

## 8. ADVANCED PATTERNS

### Pattern 1: Function Composition with Safety

```javascript
const compose =
  (...fns) =>
  (value) =>
    fns.reduceRight((acc, fn) => fn?.(acc) ?? acc, value);

const double = (x) => x * 2;
const addTen = (x) => x + 10;
const square = (x) => x * x;

const transform = compose(square, addTen, double);
console.log(transform(5)); // ((5 * 2) + 10)² = 400

// With null function in chain
const transformWithNull = compose(square, null, addTen, double);
console.log(transformWithNull(5)); // Still works: ((5 * 2) + 10)² = 400
```

### Pattern 2: Safe Property Access Helper

```javascript
const get = (obj, path, defaultValue = undefined) => {
  const keys = path.split(".");
  let result = obj;

  for (const key of keys) {
    result = result?.[key];
    if (result === undefined || result === null) {
      return defaultValue;
    }
  }

  return result ?? defaultValue;
};

const user = {
  profile: {
    address: {
      city: "Dhaka",
    },
  },
};

console.log(get(user, "profile.address.city")); // "Dhaka"
console.log(get(user, "profile.contact.email", "N/A")); // "N/A"
console.log(get(user, "profile.age", 0)); // 0
```

### Pattern 3: Conditional Object Properties

```javascript
const createUser = (data) => {
  return {
    name: data?.name ?? "Guest",
    ...(data?.email && { email: data.email }),
    ...(data?.age !== undefined && { age: data.age }),
    ...(data?.phone && { phone: data.phone }),
    settings: {
      theme: data?.settings?.theme ?? "light",
      notifications: data?.settings?.notifications ?? true,
    },
  };
};

// Only includes defined properties
console.log(createUser({ name: "John", age: 0 }));
// {
//   name: "John",
//   age: 0,           ✅ Included (0 is valid)
//   settings: { theme: "light", notifications: true }
// }

console.log(createUser({ email: "", phone: null }));
// {
//   name: "Guest",
//   settings: { theme: "light", notifications: true }
// }                   ✅ email and phone excluded
```

### Pattern 4: Pipeline with Error Handling

```javascript
const pipeline =
  (...fns) =>
  (initialValue) => {
    return fns.reduce((value, fn) => {
      try {
        return fn?.(value) ?? value;
      } catch (error) {
        console.error(`Pipeline error in ${fn?.name}:`, error.message);
        return value; // Return previous value on error
      }
    }, initialValue);
  };

const processData = pipeline(
  (x) => x?.trim(),
  (x) => x?.toUpperCase(),
  (x) => x?.split(" "),
  (x) => x?.filter(Boolean)
);

console.log(processData("  hello world  "));
// ["HELLO", "WORLD"]

console.log(processData(null));
// null (safely handled)
```

### Pattern 5: Memoization with Nullish Values

```javascript
const memoize = (fn) => {
  const cache = new Map();

  return (...args) => {
    const key = JSON.stringify(args);

    // Check if in cache (including null/undefined results)
    if (cache.has(key)) {
      console.log("From cache");
      return cache.get(key);
    }

    console.log("Computing...");
    const result = fn(...args);

    // Cache even null/undefined results
    cache.set(key, result);
    return result;
  };
};

const expensiveOperation = memoize((x) => {
  return x > 5 ? x * 2 : null; // null is valid result
});

console.log(expensiveOperation(3)); // Computing... null
console.log(expensiveOperation(3)); // From cache null
console.log(expensiveOperation(10)); // Computing... 20
console.log(expensiveOperation(10)); // From cache 20
```

---

## 9. BROWSER COMPATIBILITY

### Optional Chaining (?.)

- **ES2020** feature
- Supported in:
  - Chrome 80+ (Feb 2020)
  - Firefox 74+ (Mar 2020)
  - Safari 13.1+ (Mar 2020)
  - Edge 80+ (Feb 2020)
  - Node.js 14+

### Nullish Coalescing (??)

- **ES2020** feature
- Same support as Optional Chaining
- Supported in all modern browsers

### Polyfills (if needed)

```javascript
// Optional Chaining polyfill (simplified)
function optionalChain(obj, ...keys) {
  return keys.reduce((acc, key) => {
    return acc != null ? acc[key] : undefined;
  }, obj);
}

// Usage
const value = optionalChain(user, "address", "city");

// Nullish Coalescing polyfill
function nullishCoalesce(value, defaultValue) {
  return value !== null && value !== undefined ? value : defaultValue;
}

// Usage
const result = nullishCoalesce(user.name, "Guest");
```

### Babel Configuration

```json
{
  "presets": [
    [
      "@babel/preset-env",
      {
        "targets": {
          "browsers": ["last 2 versions", "ie >= 11"]
        }
      }
    ]
  ],
  "plugins": [
    "@babel/plugin-proposal-optional-chaining",
    "@babel/plugin-proposal-nullish-coalescing-operator"
  ]
}
```

---

## 10. BEST PRACTICES SUMMARY

### ✅ DO:

```javascript
// 1. Use optional chaining for nested access
const city = user?.address?.city;

// 2. Use ?? for numeric values, booleans, empty strings
const volume = settings.volume ?? 50;
const enabled = settings.enabled ?? false;
const text = settings.text ?? "";

// 3. Combine ?. and ??
const theme = user?.preferences?.theme ?? "light";

// 4. Use ?. for function calls
api.getData?.();

// 5. Use ?. for array access
users?.[0]?.name;

// 6. Use || for filtering falsy values when appropriate
const displayName = nickname || fullName || "Anonymous";

// 7. Use parentheses when mixing operators
const value = (a || b) ?? c;

// 8. Use for conditional rendering
const greeting = user?.name && `Welcome, ${user.name}!`;
```

### ❌ DON'T:

```javascript
// 1. Don't use || when 0, false, "" are valid
const count = userInput.count || 10; // ❌ if count can be 0

// 2. Don't forget optional chaining before ??
const name = user.profile.name ?? "Guest"; // ❌ Error if user.profile is null

// 3. Don't mix || and ?? without parentheses
const value = a || b ?? c; // ❌ SyntaxError

// 4. Don't overuse when simple checks work
if (user?.name?.first?.toLowerCase()?.trim()) {} // ❌ Too much

// 5. Don't use ?? when || is more appropriate
const message = error.message ?? error.toString() ?? "Unknown"; // ❌ Use ||

// 6. Don't forget arrays are truthy
const users = data.users ?? []; // ❌ Empty array still truthy

// 7. Don't use optional chaining for performance-critical simple checks
// Use traditional if needed in hot paths
```

---

## Quick Reference Card

```javascript
// OPTIONAL CHAINING (?.)
obj?.prop                      // Property access
obj?.[expr]                    // Dynamic property
obj?.method()                  // Method call
arr?.[index]                   // Array access

// Returns undefined if any part is null/undefined

// NULLISH COALESCING (??)
value ?? defaultValue          // Default for null/undefined only

// Falsy vs Nullish
false || true    → true        // false is falsy
false ?? true    → false       // false is not nullish

0 || 10          → 10          // 0 is falsy
0 ?? 10          → 0           // 0 is not nullish

"" || "default"  → "default"   // "" is falsy
"" ?? "default"  → ""          // "" is not nullish

null || "default" → "default"  // null is falsy AND nullish
null ?? "default" → "default"  // null is nullish

// COMBINATIONS
obj?.prop ?? defaultValue      // Safe access with default
arr?.[0]?.name ?? "Unknown"    // Array + object + default
fn?.() ?? fallbackFn?.()       // Function calls with fallback

// OPERATOR PRECEDENCE (use parentheses to clarify)
(a || b) ?? c                  // OK
a || (b ?? c)                  // OK
a || b ?? c                    // ❌ SyntaxError
```

---

## Cheat Sheet

| Scenario                   | Use         | Example                  |
| -------------------------- | ----------- | ------------------------ |
| Nested object access       | `?.`        | `user?.address?.city`    |
| Array element access       | `?.[index]` | `users?.[0]?.name`       |
| Optional function call     | `?.()`      | `callback?.()`           |
| Default for null/undefined | `??`        | `value ?? "default"`     |
| Number with 0 valid        | `??`        | `count ?? 0`             |
| Boolean with false valid   | `??`        | `enabled ?? false`       |
| Empty string valid         | `??`        | `text ?? ""`             |
| Filter all falsy           | `\|\|`      | `name \|\| "Guest"`      |
| Combining both             | `?.` + `??` | `obj?.prop ?? "default"` |

---

## সারসংক্ষেপ (Summary)

**মূল বিষয়গুলো মনে রাখো:**

1. **Optional Chaining (`?.`)** - Safe nested access, returns `undefined` instead of error
2. **Nullish Coalescing (`??`)** - Default শুধু `null`/`undefined` এর জন্য
3. **Logical OR (`||`)** - Default সব falsy values এর জন্য
4. **`??` vs `||`** - `0`, `false`, `""` valid হলে `??` use করো
5. **Combine them** - `obj?.prop ?? "default"` is powerful pattern
6. **Modern JavaScript** - ES2020+ features, widely supported
7. **Cleaner code** - Less checking, more readable
8. **Type safety** - Prevents `TypeError` crashes

এই operators master করলে defensive programming অনেক সহজ হবে এবং code cleaner হবে! 💪🚀
