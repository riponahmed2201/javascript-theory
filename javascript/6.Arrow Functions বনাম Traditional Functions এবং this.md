# Arrow Functions vs Traditional Functions ржПржмржВ `this` - рж╕ржорзНржкрзВрж░рзНржг ржЧрж╛ржЗржб

## Quick Comparison Table

| Feature                | Traditional Function        | Arrow Function          |
| ---------------------- | --------------------------- | ----------------------- |
| **Syntax**             | `function() {}`             | `() => {}`              |
| **`this` binding**     | Dynamic (caller based)      | Lexical (parent scope)  |
| **`arguments` object** | ржЖржЫрзЗ                         | ржирж╛ржЗ                     |
| **Constructor**        | `new` ржжрж┐ржпрж╝рзЗ call ржХрж░рж╛ ржпрж╛ржпрж╝   | ржпрж╛ржпрж╝ ржирж╛                 |
| **`prototype`**        | ржЖржЫрзЗ                         | ржирж╛ржЗ                     |
| **Hoisting**           | Fully hoisted (declaration) | Variable рж╣рж┐рж╕рзЗржмрзЗ hoisted |
| **Method рж╣рж┐рж╕рзЗржмрзЗ**      | ржнрж╛рж▓рзЛ                        | ржПржбрж╝рж┐ржпрж╝рзЗ ржЪрж▓рзЛ             |
| **Callback рж╣рж┐рж╕рзЗржмрзЗ**    | ржарж┐ржХ ржЖржЫрзЗ                     | Perfect!                |

## 1. SYNTAX DIFFERENCES

### Traditional Function: Traditional function ржорж╛ржирзЗ тАФ ржпрзЗржнрж╛ржмрзЗ ржЖржорж░рж╛ рж╕рж╛ржзрж╛рж░ржгржд ржлрж╛ржВрж╢ржи ржбрж┐ржлрж╛ржЗржи ржХрж░рж┐:

```javascript
// Function Declaration
function greet(name) {
  return "Hello " + name;
}

// Function Expression
const greet = function (name) {
  return "Hello " + name;
};

// Named Function Expression
const greet = function greetFunction(name) {
  return "Hello " + name;
};
```

### Arrow Function: Arrow function рж╣рж▓рзЛ ES6 (ES2015)-ржП ржЖрж╕рж╛ ржПржХржЯрж┐ shorthand syntaxред

ржПрждрзЗ function keyword рж▓рж╛ржЧрзЗ ржирж╛ ржПржмржВ `this` ржПрж░ ржЖржЪрж░ржг ржЖрж▓рж╛ржжрж╛ред

```javascript
// Basic syntax
const greet = (name) => {
  return "Hello " + name;
};

// Single parameter - parentheses optional
const greet = (name) => {
  return "Hello " + name;
};

// Implicit return (single expression)
const greet = (name) => "Hello " + name;

// Multiple parameters
const add = (a, b) => a + b;

// No parameters
const sayHi = () => "Hi!";

// Object return - parentheses ржкрзНрж░ржпрж╝рзЛржЬржи
const getPerson = () => ({ name: "John", age: 25 });
```

### Syntax Examples:

```javascript
// тЭМ Invalid Arrow Functions:
const wrong1 = name => { name: name }; // Object return ржП () ржЪрж╛ржЗ
const wrong2 = => "Hi"; // Empty params ржП () ржЪрж╛ржЗ

// тЬЕ Valid Arrow Functions:
const right1 = name => ({ name: name });
const right2 = () => "Hi";

// Multiple lines
const calculate = (a, b) => {
    const sum = a + b;
    const product = a * b;
    return { sum, product };
};

// Array methods ржП perfect
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => n * 2);
const evens = numbers.filter(n => n % 2 === 0);
```

## 2. THIS BINDING - рж╕ржмржЪрзЗржпрж╝рзЗ ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг ржкрж╛рж░рзНржержХрзНржп!

## ЁЯТб Lexical `this` Example (Arrow function ржПрж░ рж╕рзБржмрж┐ржзрж╛)

ржзрж░рзЛ рждрзБржорж┐ setTimeout ржПрж░ ржнрж┐рждрж░рзЗ traditional function ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЛ ЁЯСЗ

```js
const person = {
  name: "Ripon",
  showName: function () {
    setTimeout(function () {
      console.log(this.name);
    }, 1000);
  },
};

person.showName();
```

ЁЯз╛ Output:

```
undefined
```

ржХрж╛рж░ржг ржПржЦрж╛ржирзЗ setTimeout ржПрж░ callback ржП `this` global scope ржХрзЗ ржирж┐рж░рзНржжрзЗрж╢ ржХрж░ржЫрзЗред

ржПржЦржи arrow function ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж▓рзЗ ржжрзЗржЦрзЛ ЁЯСЗ

```js
const person = {
  name: "Ripon",
  showName: function () {
    setTimeout(() => {
      console.log(this.name);
    }, 1000);
  },
};

person.showName();
```

ЁЯз╛ Output:

```
Ripon
```

ЁЯТб ржХрж╛рж░ржг arrow function outer function (`showName`) ржПрж░ `this` capture ржХрж░рзЗ рж░рзЗржЦрзЗржЫрзЗред

---

### Traditional Function - Dynamic `this`:

`this` ржирж┐рж░рзНржнрж░ ржХрж░рзЗ **ржХрж┐ржнрж╛ржмрзЗ function call рж╣ржпрж╝рзЗржЫрзЗ** рждрж╛рж░ ржЙржкрж░ред

```javascript
const person = {
  name: "John",
  greet: function () {
    console.log("Hello, " + this.name);
  },
};

person.greet(); // "Hello, John" - this = person

const greetFunc = person.greet;
greetFunc(); // "Hello, undefined" - this = window/global (strict mode ржП undefined)
```

### Arrow Function - Lexical `this`:

`this` ржирж┐рж░рзНржнрж░ ржХрж░рзЗ **ржХрзЛржерж╛ржпрж╝ define рж╣ржпрж╝рзЗржЫрзЗ** рждрж╛рж░ ржЙржкрж░ (parent scope ржерзЗржХрзЗ inherit ржХрж░рзЗ)ред

```javascript
const person = {
  name: "John",
  greet: () => {
    console.log("Hello, " + this.name);
  },
};

person.greet(); // "Hello, undefined" - this = global/window (person ржирж╛!)
```

**ржХрзЗржи?** Arrow function ржирж┐ржЬрзЗрж░ `this` рждрзИрж░рж┐ ржХрж░рзЗ ржирж╛, parent scope ржерзЗржХрзЗ ржирзЗржпрж╝ред

## 3. THIS ржПрж░ ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд Examples

### Example 1: Object Method

```javascript
// тЭМ Arrow function - ржХрж╛ржЬ ржХрж░ржмрзЗ ржирж╛ рж╕ржарж┐ржХржнрж╛ржмрзЗ
const person = {
  name: "John",
  age: 25,
  greet: () => {
    console.log(`Hi, I'm ${this.name}`); // this = window/global
  },
};

person.greet(); // "Hi, I'm undefined"

// тЬЕ Traditional function - рж╕ржарж┐ржХ
const person2 = {
  name: "Jane",
  age: 30,
  greet: function () {
    console.log(`Hi, I'm ${this.name}`); // this = person2
  },
};

person2.greet(); // "Hi, I'm Jane"
```

### Example 2: Event Handlers

```javascript
// HTML: <button id="btn">Click Me</button>

// тЭМ Arrow function - this = window
document.getElementById("btn").addEventListener("click", () => {
  console.log(this); // Window object (button element ржирж╛!)
});

// тЬЕ Traditional function - this = button element
document.getElementById("btn").addEventListener("click", function () {
  console.log(this); // <button> element
});
```

### Example 3: Callback Functions ржП Arrow Function Perfect

```javascript
const person = {
  name: "John",
  hobbies: ["reading", "coding", "gaming"],

  // тЭМ Traditional function ржП problem
  printHobbies: function () {
    this.hobbies.forEach(function (hobby) {
      console.log(this.name + " likes " + hobby);
      // this = undefined (strict mode) or window
    });
  },

  // тЬЕ Old solution: bind ржмрж╛ variable
  printHobbies2: function () {
    const self = this; // this ржХрзЗ save ржХрж░рзЛ
    this.hobbies.forEach(function (hobby) {
      console.log(self.name + " likes " + hobby);
    });
  },

  // тЬЕтЬЕ Best: Arrow function
  printHobbies3: function () {
    this.hobbies.forEach((hobby) => {
      console.log(this.name + " likes " + hobby);
      // Arrow function parent ржПрж░ this inherit ржХрж░рзЗ
    });
  },
};

person.printHobbies3();
// John likes reading
// John likes coding
// John likes gaming
```

### Example 4: setTimeout ржП Arrow Function

```javascript
const counter = {
  count: 0,

  // тЭМ Traditional function - this рж╣рж╛рж░рж┐ржпрж╝рзЗ ржпрж╛ржпрж╝
  start: function () {
    setTimeout(function () {
      this.count++; // this = window (counter ржирж╛!)
      console.log(this.count); // NaN
    }, 1000);
  },

  // тЬЕ Arrow function - this maintain ржХрж░рзЗ
  start2: function () {
    setTimeout(() => {
      this.count++; // this = counter
      console.log(this.count); // 1
    }, 1000);
  },
};

counter.start2(); // 1 (after 1 second)
```

### Example 5: Nested Functions

```javascript
const obj = {
  name: "MyObject",

  outerFunc: function () {
    console.log(this.name); // "MyObject"

    // тЭМ Traditional nested function
    function innerFunc() {
      console.log(this.name); // undefined (this lost!)
    }
    innerFunc();

    // тЬЕ Arrow nested function
    const innerArrow = () => {
      console.log(this.name); // "MyObject" (this preserved!)
    };
    innerArrow();
  },
};

obj.outerFunc();
// Output:
// MyObject
// undefined
// MyObject
```

## 4. ARGUMENTS OBJECT

### Traditional Function - `arguments` ржЖржЫрзЗ:

```javascript
function sum() {
  console.log(arguments); // [1, 2, 3, 4, 5]
  let total = 0;
  for (let i = 0; i < arguments.length; i++) {
    total += arguments[i];
  }
  return total;
}

console.log(sum(1, 2, 3, 4, 5)); // 15
```

### Arrow Function - `arguments` ржирж╛ржЗ:

```javascript
const sum = () => {
  console.log(arguments); // ReferenceError: arguments is not defined
};

// тЬЕ Solution: Rest parameters ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЛ
const sum2 = (...numbers) => {
  console.log(numbers); // [1, 2, 3, 4, 5]
  return numbers.reduce((total, num) => total + num, 0);
};

console.log(sum2(1, 2, 3, 4, 5)); // 15
```

### Parent ржерзЗржХрзЗ `arguments` inherit:

```javascript
function outer() {
  const inner = () => {
    console.log(arguments); // outer ржПрж░ arguments access ржХрж░рзЗ
  };
  inner();
}

outer(1, 2, 3); // [1, 2, 3]
```

## 5. CONSTRUCTOR FUNCTION

### Traditional Function - Constructor рж╣рждрзЗ ржкрж╛рж░рзЗ:

```javascript
// тЬЕ Traditional function as constructor
function Person(name, age) {
  this.name = name;
  this.age = age;
}

const john = new Person("John", 25);
console.log(john); // Person { name: "John", age: 25 }
console.log(john instanceof Person); // true
```

### Arrow Function - Constructor рж╣рждрзЗ ржкрж╛рж░рзЗ ржирж╛:

```javascript
// тЭМ Arrow function as constructor
const Person = (name, age) => {
  this.name = name;
  this.age = age;
};

const john = new Person("John", 25); // TypeError: Person is not a constructor
```

## 6. PROTOTYPE

### Traditional Function - `prototype` ржЖржЫрзЗ:

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function () {
  console.log("Hello, I'm " + this.name);
};

console.log(Person.prototype); // { greet: [Function], constructor: [Function] }

const john = new Person("John");
john.greet(); // "Hello, I'm John"
```

### Arrow Function - `prototype` ржирж╛ржЗ:

```javascript
const Person = (name) => {
  this.name = name;
};

console.log(Person.prototype); // undefined

// Arrow function ржХрзЗ prototype method рж╣рж┐рж╕рзЗржмрзЗржУ add ржХрж░рж╛ ржпрж╛ржпрж╝ ржирж╛ properly
```

## 7. METHOD DEFINITION

### Object Methods:

```javascript
const calculator = {
  value: 0,

  // тЬЕ Traditional method - ржнрж╛рж▓рзЛ
  add: function (n) {
    this.value += n;
    return this;
  },

  // тЬЕ Shorthand method (ES6) - ржЖрж░рзЛ ржнрж╛рж▓рзЛ
  subtract(n) {
    this.value -= n;
    return this;
  },

  // тЭМ Arrow function - avoid ржХрж░рзЛ
  multiply: (n) => {
    this.value *= n; // this = window/global (calculator ржирж╛!)
    return this;
  },
};

calculator.add(10).subtract(3);
console.log(calculator.value); // 7
```

### Class Methods:

```javascript
class Counter {
  constructor() {
    this.count = 0;
  }

  // тЬЕ Regular method
  increment() {
    this.count++;
  }

  // тЬЕ Arrow function as class field (this binding fixed)
  decrement = () => {
    this.count--;
  };

  // Use case: Event handlers
  setupButton() {
    const btn = document.getElementById("btn");

    // тЭМ Problem: this рж╣рж╛рж░рж┐ржпрж╝рзЗ ржпрж╛ржпрж╝
    btn.addEventListener("click", this.increment);

    // тЬЕ Solution 1: Arrow function
    btn.addEventListener("click", () => this.increment());

    // тЬЕ Solution 2: Class field arrow function
    btn.addEventListener("click", this.decrement); // this preserved!
  }
}
```

## 8. IMPLICIT RETURN

### Traditional Function - рж╕ржмрж╕ржоржпрж╝ `return` keyword ржЪрж╛ржЗ:

```javascript
function double(n) {
  return n * 2; // return keyword ржкрзНрж░ржпрж╝рзЛржЬржи
}
```

### Arrow Function - Single expression ржП implicit return:

```javascript
// тЬЕ Implicit return
const double = (n) => n * 2; // return keyword рж▓рж╛ржЧрзЗ ржирж╛

// тЬЕ Array methods ржП perfect
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((n) => n * 2);
const squared = numbers.map((n) => n * n);

// тЭМ Multiple statements ржП explicit return ржЪрж╛ржЗ
const calculate = (n) => {
  const doubled = n * 2;
  const squared = n * n;
  return { doubled, squared }; // return keyword ржжрж┐рждрзЗ рж╣ржмрзЗ
};

// тЬЕ Object return ржП parentheses
const getUser = (id) => ({ id: id, name: "User" });
```

## 9. REAL-WORLD USE CASES

### Use Case 1: Array Methods

```javascript
const users = [
  { name: "John", age: 25 },
  { name: "Jane", age: 30 },
  { name: "Bob", age: 22 },
];

// тЬЕ Arrow functions perfect for array methods
const names = users.map((user) => user.name);
const adults = users.filter((user) => user.age >= 18);
const totalAge = users.reduce((sum, user) => sum + user.age, 0);

console.log(names); // ["John", "Jane", "Bob"]
console.log(adults.length); // 3
console.log(totalAge); // 77
```

### Use Case 2: Promise Chains

```javascript
// тЬЕ Arrow functions ржП cleaner
fetch("https://api.example.com/users")
  .then((response) => response.json())
  .then((data) => data.filter((user) => user.active))
  .then((activeUsers) => console.log(activeUsers))
  .catch((error) => console.error(error));

// тЭМ Traditional functions ржП verbose
fetch("https://api.example.com/users")
  .then(function (response) {
    return response.json();
  })
  .then(function (data) {
    return data.filter(function (user) {
      return user.active;
    });
  })
  .then(function (activeUsers) {
    console.log(activeUsers);
  })
  .catch(function (error) {
    console.error(error);
  });
```

### Use Case 3: React Components

```javascript
// тЬЕ Arrow functions in React
class MyComponent extends React.Component {
  state = { count: 0 };

  // Arrow function - this binding automatic
  handleClick = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <button onClick={this.handleClick}>Count: {this.state.count}</button>
    );
  }
}

// Functional components
const Greeting = ({ name }) => <h1>Hello, {name}!</h1>;
```

### Use Case 4: Async/Await

```javascript
// тЬЕ Arrow function with async/await
const fetchUserData = async (userId) => {
  try {
    const response = await fetch(`/api/users/${userId}`);
    const data = await response.json();
    return data;
  } catch (error) {
    console.error(error);
  }
};

// Array of async operations
const userIds = [1, 2, 3, 4, 5];
const fetchAllUsers = async () => {
  const users = await Promise.all(
    userIds.map(async (id) => await fetchUserData(id))
  );
  return users;
};
```

## 10. COMMON MISTAKES

### Mistake 1: Object method ржП arrow function

```javascript
// тЭМ Wrong
const person = {
  name: "John",
  greet: () => {
    console.log(`Hello, ${this.name}`); // this = window!
  },
};

// тЬЕ Correct
const person2 = {
  name: "John",
  greet() {
    console.log(`Hello, ${this.name}`);
  },
};
```

### Mistake 2: Prototype method ржП arrow function

```javascript
// тЭМ Wrong
function Person(name) {
  this.name = name;
}
Person.prototype.greet = () => {
  console.log(this.name); // this != Person instance
};

// тЬЕ Correct
Person.prototype.greet = function () {
  console.log(this.name);
};
```

### Mistake 3: Constructor рж╣рж┐рж╕рзЗржмрзЗ arrow function

```javascript
// тЭМ Wrong
const Person = (name) => {
  this.name = name;
};
new Person("John"); // TypeError

// тЬЕ Correct
function Person(name) {
  this.name = name;
}
// ржЕржержмрж╛
class Person {
  constructor(name) {
    this.name = name;
  }
}
```

### Mistake 4: arguments object expect ржХрж░рж╛

```javascript
// тЭМ Wrong
const sum = () => {
  return Array.from(arguments).reduce((a, b) => a + b); // Error!
};

// тЬЕ Correct
const sum = (...numbers) => {
  return numbers.reduce((a, b) => a + b);
};
```

## 11. INTERVIEW QUESTIONS & ANSWERS

### рзз. Arrow function ржПржмржВ traditional function ржПрж░ main ржкрж╛рж░рзНржержХрзНржп ржХрж┐?

**ржЙрждрзНрждрж░:**
"Main ржкрж╛рж░рзНржержХрзНржпржЧрзБрж▓рзЛ рж╣рж▓рзЛ:

1. **`this` binding**: Traditional function dynamic `this` (caller based), arrow function lexical `this` (parent scope ржерзЗржХрзЗ inherit)
2. **Syntax**: Arrow function concise, implicit return support ржХрж░рзЗ
3. **`arguments` object**: Traditional function ржП ржЖржЫрзЗ, arrow function ржП ржирж╛ржЗ
4. **Constructor**: Traditional function constructor рж╣рждрзЗ ржкрж╛рж░рзЗ, arrow function ржкрж╛рж░рзЗ ржирж╛
5. **Methods**: Object methods ржП traditional function use ржХрж░рж╛ ржЙржЪрж┐ржд

Example:

```javascript
const obj = {
  name: "Test",
  regular: function () {
    console.log(this.name);
  }, // 'Test'
  arrow: () => {
    console.log(this.name);
  }, // undefined
};
```

"

### рзи. ржХржЦржи arrow function ржПржмржВ ржХржЦржи traditional function use ржХрж░ржмрзЗ?

**ржЙрждрзНрждрж░:**
"**Arrow function use ржХрж░рзЛ ржпржЦржи:**

- Array methods (map, filter, reduce)
- Callback functions ржпрзЗржЦрж╛ржирзЗ parent ржПрж░ `this` ржЪрж╛ржЗ
- Promise chains
- Short, simple functions
- React event handlers (class fields)

**Traditional function use ржХрж░рзЛ ржпржЦржи:**

- Object methods
- Constructor functions
- Prototype methods
- `this` dynamic binding ржЪрж╛ржЗ
- `arguments` object ржжрж░ржХрж╛рж░

```javascript
// Arrow - callback
setTimeout(() => console.log(this.value), 1000);

// Traditional - method
const obj = {
  value: 10,
  getValue() {
    return this.value;
  },
};
```

"

### рзй. ржПржЗ code ржПрж░ output ржХрж┐ рж╣ржмрзЗ?

```javascript
const obj = {
  name: "MyObject",
  regularFunc: function () {
    console.log(this.name);
    setTimeout(function () {
      console.log(this.name);
    }, 100);
  },
  arrowFunc: function () {
    console.log(this.name);
    setTimeout(() => {
      console.log(this.name);
    }, 100);
  },
};

obj.regularFunc();
obj.arrowFunc();
```

**ржЙрждрзНрждрж░:**
"Output:

```
MyObject
undefined
MyObject
MyObject
```

**Explanation:**

- `regularFunc` ржПрж░ ржкрзНрж░ржержо console: `this` = obj, рждрж╛ржЗ 'MyObject'
- setTimeout ржПрж░ traditional function: `this` = window/undefined, рждрж╛ржЗ undefined
- `arrowFunc` ржПрж░ ржкрзНрж░ржержо console: `this` = obj, рждрж╛ржЗ 'MyObject'
- setTimeout ржПрж░ arrow function: parent ржПрж░ `this` inherit ржХрж░рзЗ (obj), рждрж╛ржЗ 'MyObject'
  "

### рзк. Arrow function ржХрж┐ hoist рж╣ржпрж╝?

**ржЙрждрзНрждрж░:**
"Arrow functions variable рж╣рж┐рж╕рзЗржмрзЗ declare ржХрж░рж╛ рж╣ржпрж╝, рждрж╛ржЗ hoisting behavior variable declaration ржПрж░ ржЙржкрж░ ржирж┐рж░рзНржнрж░ ржХрж░рзЗ:

```javascript
// var - hoisted as undefined
console.log(func1); // undefined
var func1 = () => "Hello";

// let/const - TDZ
console.log(func2); // ReferenceError
const func2 = () => "Hello";
```

Traditional function declarations fully hoisted:

```javascript
func3(); // 'Hello' - ржХрж╛ржЬ ржХрж░ржмрзЗ
function func3() {
  return "Hello";
}
```

"

### рзл. `arguments` object ржЫрж╛ржбрж╝рж╛ ржХрж┐ржнрж╛ржмрзЗ variable number of arguments handle ржХрж░ржмрзЗ?

**ржЙрждрзНрждрж░:**
"Rest parameters (`...`) ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЛ:

```javascript
// тЬЕ Arrow function with rest parameters
const sum = (...numbers) => {
  return numbers.reduce((total, num) => total + num, 0);
};

console.log(sum(1, 2, 3)); // 6
console.log(sum(1, 2, 3, 4, 5)); // 15

// Rest parameters traditional function ржПржУ ржХрж╛ржЬ ржХрж░рзЗ
function multiply(...nums) {
  return nums.reduce((product, num) => product * num, 1);
}
```

Rest parameters modern ржПржмржВ cleaner, ржХрж╛рж░ржг ржПржЯрж╛ actual array (arguments array-like object)ред"

## 12. DECISION TREE - ржХрзЛржиржЯрж╛ ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржмрзЗ?

```
Function рж▓рж┐ржЦрждрзЗ рж╣ржмрзЗ?
    тФВ
    тФЬтФА Object method? тЖТ Traditional/Shorthand
    тФВ
    тФЬтФА Constructor? тЖТ Traditional/Class
    тФВ
    тФЬтФА Prototype method? тЖТ Traditional
    тФВ
    тФЬтФА `this` parent ржерзЗржХрзЗ inherit ржХрж░рждрзЗ рж╣ржмрзЗ?
    тФВ   тФФтФА рж╣рзНржпрж╛ржБ тЖТ Arrow Function
    тФВ
    тФЬтФА Callback function? тЖТ Arrow Function (usually)
    тФВ
    тФЬтФА Array method? тЖТ Arrow Function
    тФВ
    тФЬтФА `arguments` object ржЪрж╛ржЗ? тЖТ Traditional
    тФВ
    тФФтФА Simple utility function? тЖТ Arrow Function
```

## 13. BEST PRACTICES

### тЬЕ DO:

```javascript
// 1. Array methods ржП arrow functions
const doubled = [1, 2, 3].map((n) => n * 2);

// 2. Callbacks ржП arrow functions (this preserve)
setTimeout(() => this.update(), 1000);

// 3. Object methods ржП traditional/shorthand
const obj = {
  value: 10,
  getValue() {
    return this.value;
  },
};

// 4. Single expression ржП implicit return
const square = (n) => n * n;

// 5. Rest parameters for variable args
const sum = (...nums) => nums.reduce((a, b) => a + b);
```

### тЭМ DON'T:

```javascript
// 1. Object method ржП arrow function
const obj = {
  greet: () => console.log(this.name), // тЭМ
};

// 2. Constructor рж╣рж┐рж╕рзЗржмрзЗ arrow function
const Person = (name) => {
  this.name = name;
}; // тЭМ

// 3. Prototype method ржП arrow function
Person.prototype.greet = () => console.log(this.name); // тЭМ

// 4. Dynamic this ржЪрж╛ржЗрж▓рзЗ arrow function
element.addEventListener("click", () => {
  console.log(this); // window, not element тЭМ
});
```

## Visual Summary

```
тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
тФВ           THIS BINDING                         тФВ
тФЬтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФд
тФВ                                                тФВ
тФВ  Traditional: this = WHO CALLS ME             тФВ
тФВ  Arrow:       this = WHERE I'M DEFINED        тФВ
тФВ                                                тФВ
тФВ  obj.method()     тЖТ this = obj                тФВ
тФВ  obj.arrow()      тЖТ this = parent scope       тФВ
тФВ                                                тФВ
тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ

тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
тФВ           WHEN TO USE                          тФВ
тФЬтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФд
тФВ                                                тФВ
тФВ  Arrow:          Traditional:                  тФВ
тФВ  тАв Callbacks     тАв Object methods              тФВ
тФВ  тАв Array methods тАв Constructors                тФВ
тФВ  тАв Promises      тАв Prototype methods           тФВ
тФВ  тАв Short funcs   тАв Dynamic this needed         тФВ
тФВ                                                тФВ
тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ
```

ржПржЗ concepts practice ржХрж░рзЛ ржПржмржВ different scenarios ржП code рж▓рж┐ржЦрзЗ test ржХрж░рзЛред Interview рждрзЗ `this` binding ржПрж░ clear understanding ржерж╛ржХрж▓рзЗ ржЦрзБржм ржнрж╛рж▓рзЛ impression рж╣ржмрзЗ! ЁЯОп
