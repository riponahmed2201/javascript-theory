# Event Loop, Call Stack & Concurrency - ‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶Ø‡¶º

## üöÄ ‡ßß. JavaScript Single-Threaded Language

JavaScript **single-threaded** ‚Äî ‡¶Æ‡¶æ‡¶®‡ßá ‡¶è‡¶ï‡¶∏‡¶æ‡¶•‡ßá ‡¶è‡¶ï‡¶ü‡¶æ‡¶á ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá‡•§
‡¶è‡¶ï‡¶ü‡¶æ ‚Äúmain thread‚Äù ‡¶Ü‡¶õ‡ßá, ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶ï‡ßã‡¶° execute ‡¶π‡ßü‡•§

‡¶§‡¶¨‡ßÅ‡¶ì JS ‡¶è‡¶ï‡¶∏‡¶æ‡¶•‡ßá ‡¶Ö‡¶®‡ßá‡¶ï ‡¶ï‡¶æ‡¶ú (‡¶Ø‡ßá‡¶Æ‡¶® API call, timer, DOM event) ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá ‚Äî
‡¶è‡¶ü‡¶æ ‡¶∏‡¶Æ‡ßç‡¶≠‡¶¨ ‡¶π‡ßü **Event Loop** ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø‡•§

---

## Call Stack ‡¶ï‡¶ø?

**Call Stack** ‡¶π‡¶≤‡ßã ‡¶è‡¶ï‡¶ü‡¶ø **LIFO (Last In First Out)** data structure ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá execution contexts track ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡•§ ‡¶∏‡¶¨ function execution context store ‡¶π‡ßü‡•§

### Call Stack ‡¶è‡¶∞ ‡¶ï‡¶æ‡¶ú:

- Function calls track ‡¶ï‡¶∞‡¶æ
- Currently executing function ‡¶ú‡¶æ‡¶®‡¶æ
- Function complete ‡¶π‡¶≤‡ßá remove ‡¶ï‡¶∞‡¶æ

### Example:

```javascript
function first() {
  console.log("First");
  second();
  console.log("First ‡¶∂‡ßá‡¶∑");
}

function second() {
  console.log("Second");
  third();
  console.log("Second ‡¶∂‡ßá‡¶∑");
}

function third() {
  console.log("Third");
}

first();
```

### Call Stack ‡¶è ‡¶ï‡¶ø ‡¶π‡¶¨‡ßá:

```
Step 1: [Global EC]
Step 2: [Global EC, first()]
Step 3: [Global EC, first(), second()]
Step 4: [Global EC, first(), second(), third()]
Step 5: [Global EC, first(), second()]  // third() complete
Step 6: [Global EC, first()]  // second() complete
Step 7: [Global EC]  // first() complete
Step 8: []  // Program ‡¶∂‡ßá‡¶∑
```

**Output:**

```
First
Second
Third
Second ‡¶∂‡ßá‡¶∑
First ‡¶∂‡ßá‡¶∑
```

## JavaScript Runtime Environment

JavaScript ‡¶∂‡ßÅ‡¶ß‡ßÅ Call Stack ‡¶®‡¶ø‡¶Ø‡¶º‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá ‡¶®‡¶æ‡•§ ‡¶™‡ßÅ‡¶∞‡ßã ‡¶è‡¶ï‡¶ü‡¶æ **Runtime Environment** ‡¶Ü‡¶õ‡ßá:

### Components:

1. **Call Stack** - Function execution track ‡¶ï‡¶∞‡ßá
2. **Web APIs** - Browser provide ‡¶ï‡¶∞‡ßá (setTimeout, DOM, fetch, etc.)
3. **Callback Queue** (Task Queue) - Callbacks wait ‡¶ï‡¶∞‡ßá
4. **Microtask Queue** - Promises ‡¶è‡¶∞ callbacks
5. **Event Loop** - ‡¶∏‡¶¨ coordinate ‡¶ï‡¶∞‡ßá

## Event Loop ‡¶ï‡¶ø?

**Event Loop** ‡¶π‡¶≤‡ßã ‡¶è‡¶ï‡¶ü‡¶ø mechanism ‡¶Ø‡¶æ continuously check ‡¶ï‡¶∞‡ßá:

- Call Stack empty ‡¶ï‡¶ø‡¶®‡¶æ
- Queue ‡¶§‡ßá ‡¶ï‡ßã‡¶®‡ßã task ‡¶Ü‡¶õ‡ßá ‡¶ï‡¶ø‡¶®‡¶æ

### Event Loop ‡¶è‡¶∞ ‡¶ï‡¶æ‡¶ú:

```
‡¶Ø‡¶§‡¶ï‡ßç‡¶∑‡¶£ (true) {
    ‡¶Ø‡¶¶‡¶ø (Call Stack ‡¶ñ‡¶æ‡¶≤‡¶ø) {
        ‡¶Ø‡¶¶‡¶ø (Microtask Queue ‡¶§‡ßá task ‡¶Ü‡¶õ‡ßá) {
            ‡¶∏‡ßá‡¶ü‡¶æ Call Stack ‡¶è push ‡¶ï‡¶∞‡ßã
        } ‡¶®‡¶æ‡¶π‡¶≤‡ßá ‡¶Ø‡¶¶‡¶ø (Callback Queue ‡¶§‡ßá task ‡¶Ü‡¶õ‡ßá) {
            ‡¶∏‡ßá‡¶ü‡¶æ Call Stack ‡¶è push ‡¶ï‡¶∞‡ßã
        }
    }
}
```

**Event Loop** ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá ‡¶ñ‡ßÅ‡¶¨ ‡¶∏‡¶π‡¶ú‡¶≠‡¶æ‡¶¨‡ßá üëá

> ‚ÄúIt constantly checks whether the Call Stack is empty.
> If it is empty, it takes the first callback from the Queue and pushes it to the Stack for execution.‚Äù

### üí° Steps:

1. ‡¶ï‡ßã‡¶° main thread (Call Stack) ‡¶è ‡¶ö‡¶≤‡ßá
2. Asynchronous ‡¶ï‡¶æ‡¶ú (API, timer) ‚Üí Web APIs ‡¶§‡ßá ‡¶Ø‡¶æ‡ßü
3. ‡¶ï‡¶æ‡¶ú ‡¶∂‡ßá‡¶∑ ‡¶π‡¶≤‡ßá ‚Üí Callback Queue ‡¶§‡ßá callback ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã ‡¶π‡ßü
4. Event Loop ‡¶¶‡ßá‡¶ñ‡ßá Stack ‡¶ñ‡¶æ‡¶≤‡¶ø ‡¶π‡¶≤‡ßá ‚Üí callback Stack ‡¶è ‡¶™‡¶æ‡¶†‡¶æ‡ßü
5. Callback execute ‡¶π‡ßü ‚úÖ

---

## üßÆ ‡ß´. Visual Flow

```
+--------------------------------------+
|          Call Stack                  |
|--------------------------------------|
| function executing...                |
|--------------------------------------|
| (empty)                             |
+--------------------------------------+

       ‚Üë             ‚Üì
  Event Loop   <-->  Callback Queue
                      (e.g. setTimeout callbacks)
```

‡¶è‡¶≠‡¶æ‡¶¨‡ßá JS concurrently multiple ‡¶ï‡¶æ‡¶ú manage ‡¶ï‡¶∞‡ßá,
‡¶Ø‡¶¶‡¶ø‡¶ì technically single-threaded.

---

## Asynchronous ‡¶ï‡ßã‡¶° ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá?

### Example 1: setTimeout

```javascript
console.log("Start");

setTimeout(function timeout() {
  console.log("Timeout");
}, 2000);

console.log("End");
```

### Step by Step ‡¶ï‡¶ø ‡¶π‡¶Ø‡¶º:

**Step 1:** `console.log("Start")` execute

- Output: "Start"
- Call Stack: []

**Step 2:** `setTimeout` encounter ‡¶π‡¶Ø‡¶º

- `setTimeout` Web API ‡¶§‡ßá ‡¶ö‡¶≤‡ßá ‡¶Ø‡¶æ‡¶Ø‡¶º
- Timer ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶π‡¶Ø‡¶º (2 seconds)
- Call Stack: []
- Web API: [timeout() - 2s timer]

**Step 3:** `console.log("End")` execute

- Output: "End"
- Call Stack: []

**Step 4:** 2 seconds ‡¶™‡¶∞‡ßá

- Callback function `timeout()` **Callback Queue** ‡¶§‡ßá ‡¶Ø‡¶æ‡¶Ø‡¶º
- Callback Queue: [timeout()]

**Step 5:** Event Loop check ‡¶ï‡¶∞‡ßá

- Call Stack empty? ‡¶π‡ßç‡¶Ø‡¶æ‡¶Å
- Callback Queue ‡¶§‡ßá ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶Ü‡¶õ‡ßá? ‡¶π‡ßç‡¶Ø‡¶æ‡¶Å
- `timeout()` ‡¶ï‡ßá Call Stack ‡¶è push ‡¶ï‡¶∞‡ßá

**Step 6:** `timeout()` execute ‡¶π‡¶Ø‡¶º

- Output: "Timeout"

### Final Output:

```
Start
End
Timeout
```

## Callback Queue vs Microtask Queue

### ‡¶¶‡ßÅ‡¶á‡¶ü‡¶æ Queue ‡¶Ü‡¶õ‡ßá:

#### 1. Callback Queue (Task Queue / Macrotask Queue)

‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶Ø‡¶æ‡¶Ø‡¶º:

- `setTimeout` callback
- `setInterval` callback
- DOM events
- `setImmediate`

#### 2. Microtask Queue

‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶Ø‡¶æ‡¶Ø‡¶º:

- **Promise callbacks** (`.then()`, `.catch()`, `.finally()`)
- `queueMicrotask()`
- `MutationObserver`

### **‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£:** Microtask Queue ‡¶è‡¶∞ **priority ‡¶¨‡ßá‡¶∂‡¶ø**!

Event Loop ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá **‡¶∏‡¶¨** Microtasks complete ‡¶ï‡¶∞‡ßá, ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ ‡¶è‡¶ï‡¶ü‡¶æ Macrotask ‡¶®‡ßá‡¶Ø‡¶º‡•§

## Example: Promises vs setTimeout

```javascript
console.log("Start");

setTimeout(() => {
  console.log("Timeout");
}, 0);

Promise.resolve()
  .then(() => {
    console.log("Promise 1");
  })
  .then(() => {
    console.log("Promise 2");
  });

console.log("End");
```

### Execution Order:

**Step 1:** Synchronous code

```
Output: Start
Output: End
```

**Step 2:** Queues ‡¶è tasks

```
Callback Queue: [Timeout callback]
Microtask Queue: [Promise 1 callback]
```

**Step 3:** Event Loop ‡¶ï‡¶æ‡¶ú ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡ßá

- Microtask Queue check ‡¶ï‡¶∞‡ßá (priority ‡¶¨‡ßá‡¶∂‡¶ø)

```
Output: Promise 1
```

**Step 4:** Promise 1 ‡¶è‡¶∞ `.then()` ‡¶®‡¶§‡ßÅ‡¶® microtask add ‡¶ï‡¶∞‡ßá

```
Microtask Queue: [Promise 2 callback]
```

**Step 5:** ‡¶Ü‡¶¨‡¶æ‡¶∞ Microtask Queue check

```
Output: Promise 2
```

**Step 6:** Microtask Queue empty, ‡¶è‡¶ñ‡¶® Callback Queue

```
Output: Timeout
```

### Final Output:

```
Start
End
Promise 1
Promise 2
Timeout
```

## Concurrency Model

JavaScript ‡¶è‡¶∞ **Concurrency Model** ‡¶π‡¶≤‡ßã **"Event Loop based Concurrency"**.

### ‡¶¨‡ßà‡¶∂‡¶ø‡¶∑‡ßç‡¶ü‡ßç‡¶Ø:

#### 1. Single Threaded

- ‡¶è‡¶ï‡¶ü‡¶æ ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ Call Stack
- ‡¶è‡¶ï ‡¶∏‡¶Æ‡¶Ø‡¶º‡ßá ‡¶è‡¶ï‡¶ü‡¶æ ‡¶ï‡¶æ‡¶ú

#### 2. Non-blocking

- Asynchronous operations Web API ‡¶§‡ßá ‡¶π‡¶Ø‡¶º
- Main thread block ‡¶π‡¶Ø‡¶º ‡¶®‡¶æ

#### 3. Concurrent ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ Parallel ‡¶®‡¶æ

- **Concurrent:** Multiple tasks manage ‡¶ï‡¶∞‡ßá (interleaved)
- **Parallel:** ‡¶è‡¶ï‡¶∏‡¶æ‡¶•‡ßá execute ‡¶ï‡¶∞‡ßá (JavaScript ‡¶ï‡¶∞‡ßá ‡¶®‡¶æ)

### Example: Non-blocking Nature

```javascript
console.log("1");

// Asynchronous - block ‡¶ï‡¶∞‡¶¨‡ßá ‡¶®‡¶æ
setTimeout(() => {
  console.log("2");
}, 0);

// Heavy computation - block ‡¶ï‡¶∞‡¶¨‡ßá!
for (let i = 0; i < 1000000000; i++) {
  // ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶ï‡¶∞‡¶õ‡ßá
}

console.log("3");
```

**Output:**

```
1
3
2  // ‡¶™‡¶∞‡ßá ‡¶Ü‡¶∏‡¶¨‡ßá
```

Loop ‡¶ü‡¶æ synchronous ‡¶§‡¶æ‡¶á block ‡¶ï‡¶∞‡ßá, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ setTimeout asynchronous ‡¶§‡¶æ‡¶á ‡¶™‡¶∞‡ßá execute ‡¶π‡¶Ø‡¶º‡•§

## Complex Example: ‡¶∏‡¶¨ ‡¶è‡¶ï‡¶∏‡¶æ‡¶•‡ßá

```javascript
console.log("Start");

setTimeout(() => {
  console.log("setTimeout 1");
}, 0);

Promise.resolve()
  .then(() => {
    console.log("Promise 1");
    setTimeout(() => {
      console.log("setTimeout 2");
    }, 0);
  })
  .then(() => {
    console.log("Promise 2");
  });

setTimeout(() => {
  console.log("setTimeout 3");
  Promise.resolve().then(() => {
    console.log("Promise 3");
  });
}, 0);

console.log("End");
```

### Step by Step Analysis:

**Synchronous code ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá:**

```
Output: Start
Output: End
```

**Queues:**

```
Callback Queue: [setTimeout 1, setTimeout 3]
Microtask Queue: [Promise 1]
```

**Event Loop ‡¶∂‡ßÅ‡¶∞‡ßÅ - Microtasks ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá:**

```
Output: Promise 1
```

Promise 1 ‡¶è‡¶∞ ‡¶≠‡¶ø‡¶§‡¶∞:

- ‡¶®‡¶§‡ßÅ‡¶® setTimeout ‚Üí Callback Queue ‡¶§‡ßá add
- ‡¶®‡¶§‡ßÅ‡¶® `.then()` ‚Üí Microtask Queue ‡¶§‡ßá add

**Microtask Queue:**

```
Output: Promise 2
```

**Microtask Queue empty, Callback Queue ‡¶•‡ßá‡¶ï‡ßá ‡¶è‡¶ï‡¶ü‡¶æ:**

```
Output: setTimeout 1
```

**‡¶Ü‡¶¨‡¶æ‡¶∞ Microtask check (empty), next Callback:**

```
Output: setTimeout 3
```

setTimeout 3 ‡¶è‡¶∞ ‡¶≠‡¶ø‡¶§‡¶∞ Promise:

```
Microtask Queue: [Promise 3]
```

**Microtask Queue check:**

```
Output: Promise 3
```

**Finally Callback Queue:**

```
Output: setTimeout 2
```

### Final Output:

```
Start
End
Promise 1
Promise 2
setTimeout 1
setTimeout 3
Promise 3
setTimeout 2
```

## Blocking vs Non-Blocking

### Blocking Code:

```javascript
// BAD - Call Stack block ‡¶ï‡¶∞‡ßá
function heavyTask() {
  for (let i = 0; i < 10000000000; i++) {
    // Heavy calculation
  }
}

heavyTask(); // ‡¶™‡ßÅ‡¶∞‡ßã program freeze!
console.log("Done"); // ‡¶Ö‡¶®‡ßá‡¶ï ‡¶™‡¶∞‡ßá ‡¶Ü‡¶∏‡¶¨‡ßá
```

### Non-Blocking Code:

```javascript
// GOOD - Asynchronous
function heavyTask() {
  return new Promise((resolve) => {
    setTimeout(() => {
      // Heavy task here
      resolve();
    }, 0);
  });
}

heavyTask().then(() => {
  console.log("Task complete");
});

console.log("Done"); // ‡¶§‡¶æ‡¶°‡¶º‡¶æ‡¶§‡¶æ‡¶°‡¶º‡¶ø ‡¶Ü‡¶∏‡¶¨‡ßá
```

## Interview ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶ì ‡¶â‡¶§‡ßç‡¶§‡¶∞

### ‡ßß. Event Loop ‡¶ï‡¶ø ‡¶è‡¶¨‡¶Ç ‡¶ï‡ßá‡¶® ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞?

**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
"Event Loop ‡¶π‡¶≤‡ßã JavaScript ‡¶è‡¶∞ asynchronous behavior manage ‡¶ï‡¶∞‡¶æ‡¶∞ mechanism‡•§ JavaScript single threaded ‡¶π‡¶ì‡¶Ø‡¶º‡¶æ ‡¶∏‡¶§‡ßç‡¶§‡ßç‡¶¨‡ßá‡¶ì non-blocking operations ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá Event Loop ‡¶è‡¶∞ ‡¶ï‡¶æ‡¶∞‡¶£‡ßá‡•§ ‡¶è‡¶ü‡¶æ continuously Call Stack ‡¶è‡¶¨‡¶Ç Callback Queue monitor ‡¶ï‡¶∞‡ßá, ‡¶è‡¶¨‡¶Ç Call Stack empty ‡¶π‡¶≤‡ßá queue ‡¶•‡ßá‡¶ï‡ßá tasks execute ‡¶ï‡¶∞‡ßá‡•§"

### ‡ß®. Microtask ‡¶è‡¶¨‡¶Ç Macrotask ‡¶è‡¶∞ ‡¶™‡¶æ‡¶∞‡ßç‡¶•‡¶ï‡ßç‡¶Ø ‡¶ï‡¶ø?

**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
"Microtasks ‡¶è‡¶∞ priority ‡¶¨‡ßá‡¶∂‡¶ø ‡¶è‡¶¨‡¶Ç ‡¶è‡¶ó‡ßÅ‡¶≤‡ßã ‡¶π‡¶≤‡ßã Promise callbacks, queueMicrotask‡•§ Macrotasks ‡¶π‡¶≤‡ßã setTimeout, setInterval, DOM events‡•§ Event Loop ‡¶∏‡¶¨ Microtasks complete ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶™‡¶∞‡ßá ‡¶è‡¶ï‡¶ü‡¶æ Macrotask ‡¶®‡ßá‡¶Ø‡¶º‡•§"

### ‡ß©. setTimeout(..., 0) ‡¶è‡¶∞ ‡¶Æ‡¶æ‡¶®‡ßá ‡¶ï‡¶ø?

**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
"setTimeout(..., 0) ‡¶Æ‡¶æ‡¶®‡ßá ‡¶è‡¶á ‡¶®‡¶æ ‡¶Ø‡ßá code immediately execute ‡¶π‡¶¨‡ßá‡•§ ‡¶è‡¶ü‡¶æ callback ‡¶ï‡ßá Callback Queue ‡¶§‡ßá ‡¶™‡¶æ‡¶†‡¶æ‡¶Ø‡¶º, ‡¶è‡¶¨‡¶Ç Call Stack empty ‡¶π‡¶≤‡ßá ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ execute ‡¶π‡¶Ø‡¶º‡•§ ‡¶§‡¶æ‡¶á synchronous code ‡¶∏‡¶¨ ‡¶Ü‡¶ó‡ßá execute ‡¶π‡¶¨‡ßá‡•§"

### ‡ß™. JavaScript ‡¶ï‡¶ø Concurrent ‡¶®‡¶æ‡¶ï‡¶ø Parallel?

**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
"JavaScript concurrent ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ parallel ‡¶®‡¶æ‡•§ ‡¶è‡¶ü‡¶æ multiple tasks manage ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá Event Loop ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá (concurrency), ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶è‡¶ï‡¶∏‡¶æ‡¶•‡ßá execute ‡¶ï‡¶∞‡ßá ‡¶®‡¶æ ‡¶ï‡¶æ‡¶∞‡¶£ single threaded (no parallelism)‡•§ Web Workers ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶≤‡ßá true parallelism ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡•§"

### ‡ß´. Call Stack overflow ‡¶π‡¶Ø‡¶º ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá?

**‡¶â‡¶§‡ßç‡¶§‡¶∞:**

```javascript
function recursion() {
  recursion(); // ‡¶ï‡ßã‡¶®‡ßã base case ‡¶®‡¶æ‡¶á
}

recursion(); // Stack Overflow!
```

"‡¶Ø‡¶ñ‡¶® ‡¶ñ‡ßÅ‡¶¨ ‡¶¨‡ßá‡¶∂‡¶ø function calls stack ‡¶è pile up ‡¶π‡¶Ø‡¶º, ‡¶§‡¶ñ‡¶® Call Stack ‡¶è‡¶∞ limit exceed ‡¶π‡¶Ø‡¶º‡ßá Stack Overflow error ‡¶π‡¶Ø‡¶º‡•§ ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£‡¶§ infinite recursion ‡¶è‡¶∞ ‡¶ï‡¶æ‡¶∞‡¶£‡ßá ‡¶π‡¶Ø‡¶º‡•§"

**Question:** ‚ÄúExplain Event Loop, Call Stack, and Concurrency in JavaScript.‚Äù

üëâ **Answer:**

> JavaScript is single-threaded and executes code inside a call stack.
> When asynchronous tasks like timers, API calls, or promises are triggered, they are handled by Web APIs.
> Once completed, their callbacks are sent to the Callback Queue.
> The Event Loop constantly monitors the call stack, and when it‚Äôs empty, it pushes callbacks from the queue to the stack for execution.
> This mechanism allows JavaScript to handle concurrency efficiently despite being single-threaded.

---

## üß≠ Bonus Tip for Interview:

If interviewer asks ‚Äî

> ‚ÄúHow does JS handle asynchronous operations if it‚Äôs single-threaded?‚Äù

‚úÖ You can say:

> ‚ÄúThrough the Event Loop, Web APIs, and Callback Queue system, JavaScript achieves concurrency by delegating tasks to the environment and executing callbacks later.‚Äù

---

## Visual Diagram

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     JavaScript Runtime              ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚îÇ
‚îÇ  ‚îÇ  Call Stack  ‚îÇ                  ‚îÇ
‚îÇ  ‚îÇ              ‚îÇ                  ‚îÇ
‚îÇ  ‚îÇ  [Empty]     ‚îÇ                  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  ‚îÇ
‚îÇ         ‚Üë                           ‚îÇ
‚îÇ         ‚îÇ                           ‚îÇ
‚îÇ    Event Loop ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê               ‚îÇ
‚îÇ         ‚Üë           ‚îÇ               ‚îÇ
‚îÇ         ‚îÇ           ‚îÇ               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ               ‚îÇ
‚îÇ  ‚îÇ Microtask   ‚îÇ    ‚îÇ               ‚îÇ
‚îÇ  ‚îÇ   Queue     ‚îÇ    ‚îÇ               ‚îÇ
‚îÇ  ‚îÇ [Promises]  ‚îÇ    ‚îÇ               ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ               ‚îÇ
‚îÇ         ‚Üë           ‚îÇ               ‚îÇ
‚îÇ         ‚îÇ           ‚îÇ               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ               ‚îÇ
‚îÇ  ‚îÇ Callback    ‚îÇ    ‚îÇ               ‚îÇ
‚îÇ  ‚îÇ   Queue     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îÇ
‚îÇ  ‚îÇ [setTimeout]‚îÇ                    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îÇ
‚îÇ         ‚Üë                           ‚îÇ
‚îÇ         ‚îÇ                           ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                   ‚îÇ
‚îÇ  ‚îÇ  Web APIs   ‚îÇ                   ‚îÇ
‚îÇ  ‚îÇ (Browser)   ‚îÇ                   ‚îÇ
‚îÇ  ‚îÇ setTimeout  ‚îÇ                   ‚îÇ
‚îÇ  ‚îÇ DOM, fetch  ‚îÇ                   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Key Takeaways:

1. **Call Stack** - Function execution track ‡¶ï‡¶∞‡ßá (LIFO)
2. **Event Loop** - Asynchronous coordination ‡¶ï‡¶∞‡ßá
3. **Microtasks > Macrotasks** - Priority ‡¶Æ‡¶®‡ßá ‡¶∞‡¶æ‡¶ñ‡ßã
4. **JavaScript = Single Threaded + Non-blocking** - Event Loop ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá
5. **Web APIs** - Browser provide ‡¶ï‡¶∞‡ßá asynchronous features

‡¶¶‡¶æ‡¶∞‡ßÅ‡¶£ üî•
‡¶§‡¶æ‡¶π‡¶≤‡ßá ‡¶è‡¶ñ‡¶® ‡¶ö‡¶≤‡ßã ‡¶¶‡ßá‡¶ñ‡¶ø ‚Äî
üëâ **JavaScript Event Loop, Call Stack, Callback Queue, Concurrency & Asynchronous Execution** ‚Äî ‡¶è‡¶á ‡¶ü‡¶™‡¶ø‡¶ï‡¶ó‡ßÅ‡¶≤‡ßã ‡¶∏‡¶π‡¶ú‡¶≠‡¶æ‡¶¨‡ßá, ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡ßü, **‡¶á‡¶®‡ßç‡¶ü‡¶æ‡¶∞‡¶≠‡¶ø‡¶â ‡¶∞‡ßá‡¶°‡¶ø ‡¶®‡ßã‡¶ü ‡¶Ü‡¶ï‡¶æ‡¶∞‡ßá**‡•§

---

# ‚öôÔ∏è JavaScript Event Loop, Call Stack & Concurrency (Bangla Notes)

---

## üß© ‡ßßÔ∏è. JavaScript Single Threaded ‡¶≠‡¶æ‡¶∑‡¶æ

JavaScript ‡¶π‡¶≤‡ßã **single-threaded** ‡¶≠‡¶æ‡¶∑‡¶æ ‚Äî
‡¶Æ‡¶æ‡¶®‡ßá, ‡¶è‡¶ï ‡¶∏‡¶Æ‡ßü‡ßá ‡¶è‡¶ï‡¶ü‡¶æ‡¶á ‡¶ï‡¶æ‡¶ú (task) execute ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡•§

‡¶§‡¶¨‡ßÅ‡¶ì JS ‡¶è‡¶ï‡¶∏‡¶æ‡¶•‡ßá ‡¶Ö‡¶®‡ßá‡¶ï ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá ‡¶¨‡¶≤‡ßá ‡¶Æ‡¶®‡ßá ‡¶π‡ßü,
‡¶ï‡¶æ‡¶∞‡¶£ **Event Loop** ‡¶è‡¶¨‡¶Ç **Web APIs** ‡¶è‡¶ï‡¶∏‡¶æ‡¶•‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá‡•§

---

## üß† ‡ß®Ô∏è. Call Stack ‡¶ï‡ßÄ?

Call Stack ‡¶π‡¶≤‡ßã ‡¶è‡¶ï‡¶ü‡¶ø **data structure (LIFO)** ‚Äî
‡¶Ø‡ßá‡¶ü‡¶æ JavaScript-‡¶è‡¶∞ **Execution Context** ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶ï‡¶∞‡ßá ‡¶∞‡¶æ‡¶ñ‡ßá‡•§

üëâ ‚ÄúLast In, First Out‚Äù (‡¶Ø‡ßá‡¶ü‡¶æ ‡¶∂‡ßá‡¶∑‡ßá ‡¶Ø‡¶æ‡ßü, ‡¶∏‡ßá‡¶ü‡¶æ ‡¶Ü‡¶ó‡ßá ‡¶¨‡ßá‡¶∞ ‡¶π‡ßü)

### ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£:

```js
function one() {
  console.log("One");
  two();
}

function two() {
  console.log("Two");
}

one();
```

**Execution Flow:**

```
Global ‚Üí one() ‚Üí two() ‚Üí return ‚Üí one() ‚Üí return ‚Üí Global end
```

üìä **Call Stack Visualization:**

```
|        | ‚Üê Empty (Global Done)
| one()  | ‚Üê after two() return
| two()  | ‚Üê currently executing
| one()  | ‚Üê called
| Global | ‚Üê base context
```

---

## üïπÔ∏è ‡ß©Ô∏è. Web APIs (Browser or Node APIs)

JavaScript ‡¶®‡¶ø‡¶ú‡ßá asynchronous ‡¶®‡ßü,
‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶¨‡ßç‡¶∞‡¶æ‡¶â‡¶ú‡¶æ‡¶∞ ‡¶¨‡¶æ Node.js ‡¶è‡¶∞ **Web APIs** (‡¶Ø‡ßá‡¶Æ‡¶®: `setTimeout`, `fetch`, `DOM Events`, `Promise`)
‡¶Ö‡ßç‡¶Ø‡¶æ‡¶∏‡¶ø‡¶®‡¶ï‡ßç‡¶∞‡ßã‡¶®‡¶æ‡¶∏ ‡¶ï‡¶æ‡¶ú‡¶ó‡ßÅ‡¶≤‡ßã ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡ßá‡¶≤ ‡¶ï‡¶∞‡ßá‡•§

---

## üßµ ‡ß™Ô∏è. Callback Queue (or Task Queue)

‡¶Ø‡¶ñ‡¶® ‡¶ï‡ßã‡¶®‡ßã asynchronous ‡¶ï‡¶æ‡¶ú ‡¶∂‡ßá‡¶∑ ‡¶π‡ßü,
‡¶§‡¶æ‡¶∞ callback function ‡¶ü‡¶æ **Callback Queue** ‡¶§‡ßá ‡¶ö‡¶≤‡ßá ‡¶Ø‡¶æ‡ßü‡•§

üëâ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£: `setTimeout`, `click`, `fetch` callback ‡¶á‡¶§‡ßç‡¶Ø‡¶æ‡¶¶‡¶ø

‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶è‡¶á callback ‡¶∏‡¶ô‡ßç‡¶ó‡ßá ‡¶∏‡¶ô‡ßç‡¶ó‡ßá ‡¶ö‡¶≤‡ßá ‡¶®‡¶æ,
**Event Loop** ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßá Call Stack ‡¶ñ‡¶æ‡¶≤‡¶ø ‡¶π‡¶≤‡ßá ‡¶è‡¶ï‡ßá Stack ‡¶è ‡¶™‡¶æ‡¶†‡¶æ‡ßü‡•§

---

## üîÅ ‡ß´Ô∏è. Event Loop ‡¶ï‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá?

**Event Loop** ‡¶π‡¶≤‡ßã ‡¶è‡¶ï‡¶ü‡¶æ ‡¶ï‡ßç‡¶∞‡¶Æ‡¶æ‡¶ó‡¶§ ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡ßü‡¶æ ‡¶Ø‡¶æ ‡¶ï‡¶∞‡ßá:

1. Call Stack ‡¶ñ‡¶æ‡¶≤‡¶ø ‡¶ï‡¶ø ‡¶®‡¶æ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßá
2. ‡¶ñ‡¶æ‡¶≤‡¶ø ‡¶•‡¶æ‡¶ï‡¶≤‡ßá Callback Queue ‡¶•‡ßá‡¶ï‡ßá callback ‡¶®‡¶ø‡ßü‡ßá Stack ‡¶è ‡¶¶‡ßá‡ßü
3. ‡¶è‡¶≠‡¶æ‡¶¨‡ßá ‡¶¨‡¶æ‡¶∞‡¶¨‡¶æ‡¶∞ ‡¶≤‡ßÅ‡¶™ ‡¶ï‡¶∞‡ßá ‚Äî ‡¶§‡¶æ‡¶á ‡¶®‡¶æ‡¶Æ ‚ÄúEvent Loop‚Äù

üìä **Flow Diagram:**

```
        +---------------------+
        |     Call Stack      |
        +---------------------+
                   ‚Üë
                   | (move if empty)
                   ‚Üì
        +---------------------+
        |   Event Loop        |
        +---------------------+
                   ‚Üë
                   | (push ready callbacks)
                   ‚Üì
        +---------------------+
        |   Callback Queue    |
        +---------------------+
                   ‚Üë
                   | (finished async tasks)
                   ‚Üì
        +---------------------+
        |     Web APIs        |
        +---------------------+
```

---

## ‚è±Ô∏è ‡ß¨Ô∏è. ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£: `setTimeout` Execution

```js
console.log("Start");

setTimeout(() => {
  console.log("Inside setTimeout");
}, 0);

console.log("End");
```

üëâ Output:

```
Start
End
Inside setTimeout
```

### ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ:

- `console.log("Start")` ‚Üí Stack ‡¶è ‡¶Ø‡¶æ‡ßü, execute ‡¶π‡ßü
- `setTimeout` ‚Üí Web API ‡¶§‡ßá ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã ‡¶π‡ßü
- Timer ‡¶∂‡ßá‡¶∑ ‡¶π‡¶≤‡ßá callback ‚Üí Callback Queue ‡¶§‡ßá ‡¶Ø‡¶æ‡ßü
- Stack ‡¶ñ‡¶æ‡¶≤‡¶ø ‡¶π‡¶≤‡ßá Event Loop callback ‡¶ï‡ßá Stack ‡¶è ‡¶™‡¶æ‡¶†‡¶æ‡ßü
- ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ `"Inside setTimeout"` print ‡¶π‡ßü

---

## ‚öôÔ∏è ‡ß≠Ô∏è. Microtask Queue vs Callback Queue

JavaScript ‡¶è ‡¶¶‡ßÅ‡¶ü‡¶ø Queue ‡¶Ü‡¶õ‡ßá:

| Queue               | ‡¶ï‡ßÄ ‡¶Ü‡¶∏‡ßá ‡¶è‡¶ñ‡¶æ‡¶®‡ßá                               | Priority |
| ------------------- | ------------------------------------------ | -------- |
| **Microtask Queue** | Promise `.then()`, `async/await` callbacks | ü•á High  |
| **Callback Queue**  | `setTimeout`, `setInterval`, DOM events    | ü•à Low   |

**Event Loop** ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá Microtask Queue ‚Üí ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ Callback Queue ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßá‡•§

### ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£:

```js
console.log("Start");

setTimeout(() => console.log("Timeout"), 0);
Promise.resolve().then(() => console.log("Promise"));

console.log("End");
```

üëâ Output:

```
Start
End
Promise
Timeout
```

üîπ Promise ‡¶Ü‡¶ó‡ßá execute ‡¶π‡ßü, ‡¶ï‡¶æ‡¶∞‡¶£ ‡¶è‡¶ü‡¶ø Microtask Queue ‡¶§‡ßá ‡¶Ø‡¶æ‡ßü‡•§

---

## üß© ‡ßÆÔ∏è. Concurrency & Asynchronous Nature

JavaScript asynchronous ‡¶Ü‡¶ö‡¶∞‡¶£ ‡¶ï‡¶∞‡ßá ‡¶ï‡¶æ‡¶∞‡¶£:

- Main thread ‡¶¨‡ßç‡¶≤‡¶ï ‡¶®‡¶æ ‡¶ï‡¶∞‡ßá Web APIs async ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá‡•§
- Event Loop ‡¶∏‡¶¨‡¶ï‡¶ø‡¶õ‡ßÅ coordinate ‡¶ï‡¶∞‡ßá‡•§
- Callback Queue + Microtask Queue async task handle ‡¶ï‡¶∞‡ßá‡•§

‡¶è‡¶á‡¶≠‡¶æ‡¶¨‡ßá JS ‡¶Ö‡¶®‡ßá‡¶ï ‡¶ï‡¶æ‡¶ú ‚Äú‡¶è‡¶ï‡¶∏‡¶æ‡¶•‡ßá‚Äù ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá ‡¶¨‡¶≤‡ßá ‡¶Æ‡¶®‡ßá ‡¶π‡ßü, ‡¶Ø‡¶¶‡¶ø‡¶ì technically ‡¶è‡¶ï ‡¶•‡ßç‡¶∞‡ßá‡¶°‡ßá ‡¶ö‡¶≤‡ßá‡•§

---

## üß† ‡ßØÔ∏è. Interview Quick Notes (Summary)

‚úÖ JS ‡¶π‡¶≤‡ßã Single Threaded ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ Non-blocking
‚úÖ Execution Stack = ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶ï‡ßã‡¶° execute ‡¶π‡ßü
‚úÖ Web APIs = async ‡¶ï‡¶æ‡¶ú handle ‡¶ï‡¶∞‡ßá
‚úÖ Callback Queue = async callback ‡¶ß‡¶∞‡ßá ‡¶∞‡¶æ‡¶ñ‡ßá
‚úÖ Event Loop = Queue ‚Üí Stack coordination ‡¶ï‡¶∞‡ßá
‚úÖ Promise callbacks ‡¶Ü‡¶ó‡ßá ‡¶ö‡¶≤‡ßá (Microtask Queue priority)
‚úÖ `setTimeout(..., 0)` ‡¶π‡¶≤‡ßá‡¶ì Promise ‡¶Ü‡¶ó‡ßá execute ‡¶π‡ßü

---

## üéØ Bonus (‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶Ø‡¶æ ‡¶á‡¶®‡ßç‡¶ü‡¶æ‡¶∞‡¶≠‡¶ø‡¶â‡¶§‡ßá ‡¶Ü‡¶∏‡ßá)

1Ô∏è‚É£ ‚ÄúWhy is JavaScript single-threaded but non-blocking?‚Äù
‚û° Because async tasks handled by Web APIs + Event Loop, not by main thread.

2Ô∏è‚É£ ‚ÄúWhat‚Äôs the difference between Call Stack and Event Loop?‚Äù
‚û° Call Stack executes code; Event Loop manages async callback flow.

3Ô∏è‚É£ ‚ÄúWhich executes first: Promise or setTimeout?‚Äù
‚û° Promise (Microtask Queue > Callback Queue).

---
