# Classes, Objects & Getters/Setters - ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶ó‡¶æ‡¶á‡¶° ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶Ø‡¶º

## Table of Contents

1. Objects Basics
2. Classes (ES6+)
3. Getters & Setters
4. Inheritance
5. Static Methods
6. Private Fields
7. Real-world Examples

---

## 1. OBJECTS BASICS

### Object Creation Methods

#### Method 1: Object Literal (‡¶∏‡¶¨‡¶ö‡ßá‡¶Ø‡¶º‡ßá common)

```javascript
const person = {
  name: "John",
  age: 25,
  city: "Dhaka",

  greet: function () {
    console.log(`Hello, I'm ${this.name}`);
  },

  // ES6 Shorthand method
  introduce() {
    console.log(`I'm ${this.name}, ${this.age} years old`);
  },
};

console.log(person.name); // "John"
person.greet(); // "Hello, I'm John"
```

#### Method 2: Object Constructor

```javascript
const person = new Object();
person.name = "Jane";
person.age = 30;
person.greet = function () {
  console.log(`Hi, I'm ${this.name}`);
};
```

#### Method 3: Constructor Function (Pre-ES6)

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;

  this.greet = function () {
    console.log(`Hello, I'm ${this.name}`);
  };
}

const john = new Person("John", 25);
const jane = new Person("Jane", 30);

john.greet(); // "Hello, I'm John"
```

#### Method 4: Object.create()

```javascript
const personPrototype = {
  greet: function () {
    console.log(`Hello, I'm ${this.name}`);
  },
};

const john = Object.create(personPrototype);
john.name = "John";
john.age = 25;

john.greet(); // "Hello, I'm John"
```

### Accessing Object Properties

```javascript
const person = {
  name: "John",
  age: 25,
  "favorite color": "blue", // Space ‡¶•‡¶æ‡¶ï‡¶≤‡ßá quotes ‡¶ö‡¶æ‡¶á
};

// Dot notation
console.log(person.name); // "John"

// Bracket notation
console.log(person["age"]); // 25
console.log(person["favorite color"]); // "blue"

// Dynamic property access
const prop = "name";
console.log(person[prop]); // "John"
```

### Adding/Modifying/Deleting Properties

```javascript
const person = {
  name: "John",
};

// Adding
person.age = 25;
person["city"] = "Dhaka";

// Modifying
person.name = "Jane";

// Deleting
delete person.city;

console.log(person); // { name: "Jane", age: 25 }
```

---

## 2. CLASSES (ES6+)

> Classes ‡¶π‡¶≤‡ßã objects ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø modern ‡¶è‡¶¨‡¶Ç cleaner way‡•§

> **Class** ‡¶π‡¶≤‡ßã object ‡¶§‡ßà‡¶∞‡¶ø‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø template ‡¶¨‡¶æ blueprint‡•§
> ‡¶è‡¶ï‡¶á ‡¶ß‡¶∞‡¶®‡ßá‡¶∞ properties ‡¶è‡¶¨‡¶Ç methods ‡¶è‡¶ï‡¶∏‡¶æ‡¶•‡ßá ‡¶∏‡¶Ç‡¶∞‡¶ï‡ßç‡¶∑‡¶£ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø Class ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶π‡ßü‡•§

üëâ ‡¶Ö‡¶∞‡ßç‡¶•‡¶æ‡ßé, class ‡¶π‡¶≤‡ßã ‡¶è‡¶ï‡¶ß‡¶∞‡¶®‡ßá‡¶∞ factory, ‡¶Ø‡ßá‡¶ü‡¶æ ‡¶•‡ßá‡¶ï‡ßá ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶Ö‡¶®‡ßá‡¶ï‡¶ó‡ßÅ‡¶≤‡ßã object ‡¶¨‡¶æ‡¶®‡¶æ‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø‡•§

### Basic Class Syntax

```javascript
class Person {
  // Constructor - object ‡¶§‡ßà‡¶∞‡¶ø ‡¶π‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º call ‡¶π‡¶Ø‡¶º
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  // Methods
  greet() {
    console.log(`Hello, I'm ${this.name}`);
  }

  introduce() {
    console.log(`I'm ${this.name}, ${this.age} years old`);
  }

  // Method with parameters
  celebrateBirthday() {
    this.age++;
    console.log(`Happy Birthday! Now I'm ${this.age}`);
  }
}

// Creating instances
const john = new Person("John", 25);
const jane = new Person("Jane", 30);

john.greet(); // "Hello, I'm John"
john.celebrateBirthday(); // "Happy Birthday! Now I'm 26"
```

### Class vs Constructor Function

```javascript
// ‚ùå Old way - Constructor Function
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.greet = function () {
  console.log(`Hello, I'm ${this.name}`);
};

// ‚úÖ Modern way - Class
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  greet() {
    console.log(`Hello, I'm ${this.name}`);
  }
}
```

Classes internally constructor functions ‡¶è‡¶∞ syntactic sugar, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ cleaner ‡¶è‡¶¨‡¶Ç readable‡•§

---

## 3. GETTERS & SETTERS

Getters ‡¶è‡¶¨‡¶Ç Setters ‡¶π‡¶≤‡ßã special methods ‡¶Ø‡¶æ properties ‡¶ï‡ßá read/write ‡¶ï‡¶∞‡¶§‡ßá ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§ ‡¶π‡¶Ø‡¶º‡•§

### Basic Getters & Setters

```javascript
class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  // Getter - property ‡¶è‡¶∞ ‡¶Æ‡¶§‡ßã access ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  // Setter - property ‡¶è‡¶∞ ‡¶Æ‡¶§‡ßã set ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º
  set fullName(name) {
    const parts = name.split(" ");
    this.firstName = parts[0];
    this.lastName = parts[1];
  }
}

const person = new Person("John", "Doe");

// Getter ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ (function call ‡¶è‡¶∞ ‡¶Æ‡¶§‡ßã ‡¶®‡¶æ, property ‡¶è‡¶∞ ‡¶Æ‡¶§‡ßã)
console.log(person.fullName); // "John Doe"

// Setter ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞
person.fullName = "Jane Smith";
console.log(person.firstName); // "Jane"
console.log(person.lastName); // "Smith"
```

### Why Use Getters & Setters?

#### 1. **Validation**

```javascript
class User {
  constructor(name, age) {
    this.name = name;
    this._age = age; // underscore = convention for "private"
  }

  get age() {
    return this._age;
  }

  set age(value) {
    // Validation
    if (value < 0 || value > 150) {
      console.log("Invalid age!");
      return;
    }
    this._age = value;
  }
}

const user = new User("John", 25);
console.log(user.age); // 25

user.age = 30; // Valid
console.log(user.age); // 30

user.age = -5; // "Invalid age!"
console.log(user.age); // 30 (unchanged)
```

#### 2. **Computed Properties**

```javascript
class Rectangle {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }

  // Computed property
  get area() {
    return this.width * this.height;
  }

  get perimeter() {
    return 2 * (this.width + this.height);
  }
}

const rect = new Rectangle(10, 5);
console.log(rect.area); // 50
console.log(rect.perimeter); // 30

// area dynamically calculate ‡¶π‡¶Ø‡¶º
rect.width = 20;
console.log(rect.area); // 100
```

#### 3. **Read-only Properties**

```javascript
class Product {
  constructor(name, price) {
    this._name = name;
    this._price = price;
    this._id = Date.now(); // Unique ID
  }

  // Read-only - ‡¶∂‡ßÅ‡¶ß‡ßÅ getter, setter ‡¶®‡¶æ‡¶á
  get id() {
    return this._id;
  }

  get name() {
    return this._name;
  }

  set name(value) {
    if (value.length < 3) {
      console.log("Name too short!");
      return;
    }
    this._name = value;
  }

  get price() {
    return this._price;
  }

  set price(value) {
    if (value < 0) {
      console.log("Price can't be negative!");
      return;
    }
    this._price = value;
  }
}

const product = new Product("Laptop", 50000);
console.log(product.id); // 1234567890 (example)

product.id = 999; // Setter ‡¶®‡¶æ‡¶á, ‡¶§‡¶æ‡¶á change ‡¶π‡¶¨‡ßá ‡¶®‡¶æ
console.log(product.id); // Still 1234567890
```

#### 4. **Data Formatting**

```javascript
class BankAccount {
  constructor(accountNumber, balance) {
    this._accountNumber = accountNumber;
    this._balance = balance;
  }

  // Format ‡¶ï‡¶∞‡ßá return
  get accountNumber() {
    // Format: XXXX-XXXX-XXXX-1234
    const str = this._accountNumber.toString();
    return "XXXX-XXXX-XXXX-" + str.slice(-4);
  }

  get balance() {
    // Format: ‡ß≥ 50,000.00
    return `‡ß≥ ${this._balance.toLocaleString("en-BD", {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    })}`;
  }

  // Setter - raw value store ‡¶ï‡¶∞‡ßá
  set balance(value) {
    if (value < 0) {
      console.log("Balance can't be negative!");
      return;
    }
    this._balance = value;
  }
}

const account = new BankAccount(123456789012, 50000);
console.log(account.accountNumber); // "XXXX-XXXX-XXXX-9012"
console.log(account.balance); // "‡ß≥ 50,000.00"
```

### Object Literal ‡¶è Getters/Setters

```javascript
const person = {
  firstName: "John",
  lastName: "Doe",

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },

  set fullName(name) {
    const parts = name.split(" ");
    this.firstName = parts[0];
    this.lastName = parts[1];
  },
};

console.log(person.fullName); // "John Doe"
person.fullName = "Jane Smith";
console.log(person.firstName); // "Jane"
```

---

## 4. INHERITANCE (‡¶â‡¶§‡ßç‡¶§‡¶∞‡¶æ‡¶ß‡¶ø‡¶ï‡¶æ‡¶∞)

‡¶è‡¶ï‡¶ü‡¶æ class ‡¶Ö‡¶®‡ßç‡¶Ø class ‡¶•‡ßá‡¶ï‡ßá properties ‡¶è‡¶¨‡¶Ç methods inherit ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡•§

### Basic Inheritance

```javascript
// Parent class
class Animal {
  constructor(name) {
    this.name = name;
  }

  eat() {
    console.log(`${this.name} is eating`);
  }

  sleep() {
    console.log(`${this.name} is sleeping`);
  }
}

// Child class - extends ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá inherit ‡¶ï‡¶∞‡ßá
class Dog extends Animal {
  constructor(name, breed) {
    super(name); // Parent constructor call ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶¨‡ßá
    this.breed = breed;
  }

  bark() {
    console.log(`${this.name} says: Woof! Woof!`);
  }

  // Method overriding
  eat() {
    console.log(`${this.name} the dog is eating dog food`);
  }
}

const dog = new Dog("Buddy", "Golden Retriever");
dog.eat(); // "Buddy the dog is eating dog food" (overridden)
dog.sleep(); // "Buddy is sleeping" (inherited)
dog.bark(); // "Buddy says: Woof! Woof!" (own method)
```

### super Keyword

```javascript
class Vehicle {
  constructor(brand, model) {
    this.brand = brand;
    this.model = model;
  }

  getInfo() {
    return `${this.brand} ${this.model}`;
  }
}

class Car extends Vehicle {
  constructor(brand, model, doors) {
    super(brand, model); // Parent constructor
    this.doors = doors;
  }

  // Parent method call ‡¶ï‡¶∞‡¶æ
  getInfo() {
    const info = super.getInfo(); // Parent method
    return `${info} with ${this.doors} doors`;
  }
}

const car = new Car("Toyota", "Corolla", 4);
console.log(car.getInfo()); // "Toyota Corolla with 4 doors"
```

### Multi-level Inheritance

```javascript
class LivingBeing {
  constructor(name) {
    this.name = name;
  }

  breathe() {
    console.log(`${this.name} is breathing`);
  }
}

class Animal extends LivingBeing {
  constructor(name, species) {
    super(name);
    this.species = species;
  }

  move() {
    console.log(`${this.name} is moving`);
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name, "Dog");
    this.breed = breed;
  }

  bark() {
    console.log(`${this.name} says: Woof!`);
  }
}

const dog = new Dog("Max", "Labrador");
dog.breathe(); // From LivingBeing
dog.move(); // From Animal
dog.bark(); // From Dog
```

---

## 5. STATIC METHODS & PROPERTIES

Static members class ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá associated, instances ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶®‡¶æ‡•§

### Static Methods

```javascript
class MathHelper {
  // Static method - class ‡¶•‡ßá‡¶ï‡ßá directly call ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶Ø‡¶º
  static add(a, b) {
    return a + b;
  }

  static multiply(a, b) {
    return a * b;
  }

  static PI = 3.14159; // Static property
}

// ‚úÖ Class ‡¶•‡ßá‡¶ï‡ßá call ‡¶ï‡¶∞‡ßã
console.log(MathHelper.add(5, 3)); // 8
console.log(MathHelper.PI); // 3.14159

// ‚ùå Instance ‡¶•‡ßá‡¶ï‡ßá call ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º ‡¶®‡¶æ
const helper = new MathHelper();
console.log(helper.add(5, 3)); // undefined (error)
```

### Use Cases for Static Methods

#### 1. **Utility Functions**

```javascript
class StringHelper {
  static capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  static reverse(str) {
    return str.split("").reverse().join("");
  }

  static toKebabCase(str) {
    return str.toLowerCase().replace(/\s+/g, "-");
  }
}

console.log(StringHelper.capitalize("hello")); // "Hello"
console.log(StringHelper.reverse("hello")); // "olleh"
console.log(StringHelper.toKebabCase("Hello World")); // "hello-world"
```

#### 2. **Factory Methods**

```javascript
class User {
  constructor(name, email, role) {
    this.name = name;
    this.email = email;
    this.role = role;
  }

  // Static factory methods
  static createAdmin(name, email) {
    return new User(name, email, "admin");
  }

  static createGuest(name) {
    return new User(name, "guest@example.com", "guest");
  }

  static createFromJSON(json) {
    const data = JSON.parse(json);
    return new User(data.name, data.email, data.role);
  }
}

const admin = User.createAdmin("John", "john@example.com");
const guest = User.createGuest("Anonymous");
const fromJSON = User.createFromJSON(
  '{"name":"Jane","email":"jane@ex.com","role":"user"}'
);

console.log(admin); // User { name: "John", email: "john@example.com", role: "admin" }
```

#### 3. **Counter/Tracker**

```javascript
class User {
  static userCount = 0; // Static property

  constructor(name) {
    this.name = name;
    this.id = ++User.userCount; // Increment count
  }

  static getTotalUsers() {
    return User.userCount;
  }

  static resetCount() {
    User.userCount = 0;
  }
}

const user1 = new User("John");
const user2 = new User("Jane");
const user3 = new User("Bob");

console.log(User.getTotalUsers()); // 3
console.log(user1.id); // 1
console.log(user2.id); // 2
console.log(user3.id); // 3
```

---

## 6. PRIVATE FIELDS (ES2022+)

`#` ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá private fields/methods ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡•§

### Private Fields

```javascript
class BankAccount {
  #balance = 0; // Private field
  #pin; // Private field

  constructor(accountHolder, initialBalance, pin) {
    this.accountHolder = accountHolder; // Public
    this.#balance = initialBalance; // Private
    this.#pin = pin; // Private
  }

  // Public method
  deposit(amount) {
    if (amount > 0) {
      this.#balance += amount;
      console.log(`Deposited: ‡ß≥${amount}`);
    }
  }

  // Public method
  withdraw(amount, pin) {
    if (!this.#validatePin(pin)) {
      console.log("Invalid PIN!");
      return;
    }

    if (amount > this.#balance) {
      console.log("Insufficient balance!");
      return;
    }

    this.#balance -= amount;
    console.log(`Withdrawn: ‡ß≥${amount}`);
  }

  // Private method
  #validatePin(pin) {
    return pin === this.#pin;
  }

  // Getter for balance
  get balance() {
    return this.#balance;
  }
}

const account = new BankAccount("John Doe", 10000, 1234);

account.deposit(5000);
console.log(account.balance); // 15000

account.withdraw(3000, 1234); // Success
account.withdraw(3000, 9999); // "Invalid PIN!"

// ‚ùå Private fields directly access ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º ‡¶®‡¶æ
console.log(account.#balance); // SyntaxError
console.log(account.#pin); // SyntaxError
account.#validatePin(1234); // SyntaxError
```

### Private vs "Pseudo-private" (\_convention)

```javascript
// ‚ùå Old way - underscore convention (not truly private)
class OldWay {
  constructor() {
    this._private = "Not really private";
  }
}

const old = new OldWay();
console.log(old._private); // Accessible! (just convention)

// ‚úÖ New way - truly private
class NewWay {
  #private = "Truly private";
}

const newWay = new NewWay();
console.log(newWay.#private); // SyntaxError - Not accessible!
```

---

## 7. REAL-WORLD EXAMPLES

### Example 1: User Management System

```javascript
class User {
  static #userCount = 0;
  #password;

  constructor(username, email, password) {
    this.id = ++User.#userCount;
    this.username = username;
    this.email = email;
    this.#password = this.#hashPassword(password);
    this.createdAt = new Date();
    this.isActive = true;
  }

  // Private method
  #hashPassword(password) {
    // Simple hash (real app ‡¶è bcrypt/crypto use ‡¶ï‡¶∞‡ßã)
    return password.split("").reverse().join("");
  }

  // Validate password
  validatePassword(password) {
    return this.#hashPassword(password) === this.#password;
  }

  // Change password
  changePassword(oldPassword, newPassword) {
    if (!this.validatePassword(oldPassword)) {
      console.log("Incorrect old password!");
      return false;
    }

    if (newPassword.length < 6) {
      console.log("Password too short!");
      return false;
    }

    this.#password = this.#hashPassword(newPassword);
    console.log("Password changed successfully!");
    return true;
  }

  // Deactivate account
  deactivate() {
    this.isActive = false;
    console.log(`User ${this.username} deactivated`);
  }

  // Get user info (without password)
  getInfo() {
    return {
      id: this.id,
      username: this.username,
      email: this.email,
      isActive: this.isActive,
      createdAt: this.createdAt,
    };
  }

  // Static method
  static getTotalUsers() {
    return User.#userCount;
  }
}

// Usage
const user1 = new User("john_doe", "john@example.com", "secret123");
const user2 = new User("jane_doe", "jane@example.com", "pass456");

console.log(user1.getInfo());
console.log(User.getTotalUsers()); // 2

user1.changePassword("secret123", "newpass123");
console.log(user1.validatePassword("newpass123")); // true
```

### Example 2: Shopping Cart

```javascript
class Product {
  constructor(id, name, price, stock) {
    this.id = id;
    this.name = name;
    this.price = price;
    this.stock = stock;
  }

  get isAvailable() {
    return this.stock > 0;
  }
}

class CartItem {
  #product;
  #quantity;

  constructor(product, quantity = 1) {
    this.#product = product;
    this.#quantity = quantity;
  }

  get product() {
    return this.#product;
  }

  get quantity() {
    return this.#quantity;
  }

  set quantity(value) {
    if (value < 1) {
      console.log("Quantity must be at least 1");
      return;
    }

    if (value > this.#product.stock) {
      console.log(`Only ${this.#product.stock} items available`);
      return;
    }

    this.#quantity = value;
  }

  get total() {
    return this.#product.price * this.#quantity;
  }
}

class ShoppingCart {
  #items = [];

  addItem(product, quantity = 1) {
    // Check if product already in cart
    const existingItem = this.#items.find(
      (item) => item.product.id === product.id
    );

    if (existingItem) {
      existingItem.quantity += quantity;
    } else {
      this.#items.push(new CartItem(product, quantity));
    }

    console.log(`Added ${quantity}x ${product.name} to cart`);
  }

  removeItem(productId) {
    const index = this.#items.findIndex(
      (item) => item.product.id === productId
    );

    if (index !== -1) {
      const removed = this.#items.splice(index, 1)[0];
      console.log(`Removed ${removed.product.name} from cart`);
    }
  }

  updateQuantity(productId, quantity) {
    const item = this.#items.find((item) => item.product.id === productId);

    if (item) {
      item.quantity = quantity;
    }
  }

  get items() {
    return [...this.#items]; // Copy return ‡¶ï‡¶∞‡ßã
  }

  get itemCount() {
    return this.#items.reduce((sum, item) => sum + item.quantity, 0);
  }

  get subtotal() {
    return this.#items.reduce((sum, item) => sum + item.total, 0);
  }

  get tax() {
    return this.subtotal * 0.15; // 15% tax
  }

  get total() {
    return this.subtotal + this.tax;
  }

  clear() {
    this.#items = [];
    console.log("Cart cleared");
  }

  checkout() {
    if (this.#items.length === 0) {
      console.log("Cart is empty!");
      return;
    }

    console.log("\n========== CHECKOUT ==========");
    this.#items.forEach((item) => {
      console.log(`${item.product.name} x${item.quantity} = ‡ß≥${item.total}`);
    });
    console.log(`Subtotal: ‡ß≥${this.subtotal}`);
    console.log(`Tax (15%): ‡ß≥${this.tax.toFixed(2)}`);
    console.log(`Total: ‡ß≥${this.total.toFixed(2)}`);
    console.log("==============================\n");
  }
}

// Usage
const laptop = new Product(1, "Laptop", 50000, 10);
const mouse = new Product(2, "Mouse", 500, 50);
const keyboard = new Product(3, "Keyboard", 1500, 30);

const cart = new ShoppingCart();
cart.addItem(laptop, 1);
cart.addItem(mouse, 2);
cart.addItem(keyboard, 1);

console.log(`Items in cart: ${cart.itemCount}`);
cart.checkout();
```

### Example 3: Temperature Converter

```javascript
class Temperature {
  #celsius;

  constructor(celsius) {
    this.#celsius = celsius;
  }

  // Getters for different units
  get celsius() {
    return this.#celsius;
  }

  get fahrenheit() {
    return (this.#celsius * 9) / 5 + 32;
  }

  get kelvin() {
    return this.#celsius + 273.15;
  }

  // Setters for different units
  set celsius(value) {
    this.#celsius = value;
  }

  set fahrenheit(value) {
    this.#celsius = ((value - 32) * 5) / 9;
  }

  set kelvin(value) {
    this.#celsius = value - 273.15;
  }

  // Display all units
  display() {
    console.log(`Celsius: ${this.celsius.toFixed(2)}¬∞C`);
    console.log(`Fahrenheit: ${this.fahrenheit.toFixed(2)}¬∞F`);
    console.log(`Kelvin: ${this.kelvin.toFixed(2)}K`);
  }

  // Static conversion methods
  static celsiusToFahrenheit(c) {
    return (c * 9) / 5 + 32;
  }

  static fahrenheitToCelsius(f) {
    return ((f - 32) * 5) / 9;
  }

  static celsiusToKelvin(c) {
    return c + 273.15;
  }
}

// Usage
const temp = new Temperature(25);
temp.display();
// Celsius: 25.00¬∞C
// Fahrenheit: 77.00¬∞F
// Kelvin: 298.15K

temp.fahrenheit = 100; // Set using Fahrenheit
temp.display();
// Celsius: 37.78¬∞C
// Fahrenheit: 100.00¬∞F
// Kelvin: 310.93K

// Static methods
console.log(Temperature.celsiusToFahrenheit(0)); // 32
```

---

## 8. INTERVIEW QUESTIONS & ANSWERS

## üß† Interview Notes

| ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®                            | ‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§ ‡¶â‡¶§‡ßç‡¶§‡¶∞                              |
| --------------------------------- | -------------------------------------------- |
| Class ‡¶ï‡ßÄ?                         | Object ‡¶§‡ßà‡¶∞‡¶ø‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶è‡¶ï‡¶ü‡¶ø template ‡¶¨‡¶æ blueprint |
| Constructor ‡¶è‡¶∞ ‡¶ï‡¶æ‡¶ú ‡¶ï‡ßÄ?            | Object ‡¶§‡ßà‡¶∞‡¶ø‡¶∞ ‡¶∏‡¶Æ‡ßü property initialize ‡¶ï‡¶∞‡¶æ     |
| `this` ‡¶ï‡ßÄ ‡¶¨‡ßã‡¶ù‡¶æ‡ßü?                  | ‡¶Ø‡ßá object ‡¶ü‡¶ø ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶®‡ßá ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§ ‡¶π‡¶ö‡ßç‡¶õ‡ßá          |
| `extends` ‡¶ì `super` ‡¶è‡¶∞ ‡¶ï‡¶æ‡¶ú ‡¶ï‡ßÄ?    | Class inheritance ‡¶ï‡¶∞‡¶§‡ßá ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§ ‡¶π‡ßü            |
| Getter ‡¶ì Setter ‡¶è‡¶∞ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡ßÄ?    | Property access ‡¶ì validation control ‡¶ï‡¶∞‡¶æ     |
| Static method ‡¶ï‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá call ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü? | Class name ‡¶¶‡¶ø‡ßü‡ßá, object ‡¶õ‡¶æ‡ßú‡¶æ                 |
| Private field ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá declare ‡¶π‡ßü?  | `#` ‡¶ö‡¶ø‡¶π‡ßç‡¶® ‡¶¶‡¶ø‡ßü‡ßá (ES2022+)                     |

---

## üéØ Summary:

- Class = Object ‡¶§‡ßà‡¶∞‡¶ø‡¶∞ blueprint
- Object = Class ‡¶è‡¶∞ instance
- Getter/Setter = Data control ‡¶ì validation
- Inheritance = Code reusability
- Static = Class-level utility method
- Private field = Data encapsulation

---

### ‡ßß. Class ‡¶è‡¶¨‡¶Ç Object ‡¶è‡¶∞ ‡¶™‡¶æ‡¶∞‡ßç‡¶•‡¶ï‡ßç‡¶Ø ‡¶ï‡¶ø?

**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
"**Class** ‡¶π‡¶≤‡ßã ‡¶è‡¶ï‡¶ü‡¶ø blueprint/template ‡¶Ø‡¶æ ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá objects ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡•§ **Object** ‡¶π‡¶≤‡ßã class ‡¶è‡¶∞ instance‡•§

```javascript
// Class - blueprint
class Car {
  constructor(brand, model) {
    this.brand = brand;
    this.model = model;
  }
}

// Objects - instances
const car1 = new Car("Toyota", "Corolla");
const car2 = new Car("Honda", "Civic");
```

‡¶è‡¶ï‡¶ü‡¶æ class ‡¶•‡ßá‡¶ï‡ßá multiple objects ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º, ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶æ‡¶∞ ‡¶®‡¶ø‡¶ú‡¶∏‡ßç‡¶¨ data ‡¶•‡¶æ‡¶ï‡ßá‡•§"

### ‡ß®. Getters ‡¶è‡¶¨‡¶Ç Setters ‡¶ï‡ßá‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶¨‡ßá?

**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
"Getters/Setters ‡¶è‡¶∞ main benefits:

1. **Validation:** Data set ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶Ü‡¶ó‡ßá validate ‡¶ï‡¶∞‡¶æ
2. **Computed Properties:** Dynamic values calculate ‡¶ï‡¶∞‡¶æ
3. **Encapsulation:** Internal representation hide ‡¶ï‡¶∞‡¶æ
4. **Read-only Properties:** ‡¶∂‡ßÅ‡¶ß‡ßÅ read access ‡¶¶‡ßá‡¶ì‡¶Ø‡¶º‡¶æ

```javascript
class User {
  constructor(name, age) {
    this._age = age;
  }

  get age() {
    return this._age;
  }

  set age(value) {
    if (value < 0 || value > 150) {
      throw new Error("Invalid age");
    }
    this._age = value;
  }
}
```

Simple property access syntax ‡¶è validation/logic add ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡•§"

### ‡ß©. Static methods ‡¶ï‡¶ñ‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶¨‡ßá?

**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
"Static methods ‡¶§‡¶ñ‡¶® use ‡¶ï‡¶∞‡ßã ‡¶Ø‡¶ñ‡¶®:

1. **Utility functions:** Instance data ‡¶è‡¶∞ ‡¶â‡¶™‡¶∞ depend ‡¶ï‡¶∞‡ßá ‡¶®‡¶æ
2. **Factory methods:** Objects ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ‡¶∞ alternative ways
3. **Helper functions:** Class related ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ instance specific ‡¶®‡¶æ

```javascript
class MathHelper {
  static add(a, b) {
    return a + b; // Instance data ‡¶ö‡¶æ‡¶á ‡¶®‡¶æ
  }
}

// Class ‡¶•‡ßá‡¶ï‡ßá directly call
MathHelper.add(5, 3); // 8

// Instance ‡¶•‡ßá‡¶ï‡ßá ‡¶®‡¶æ
const helper = new MathHelper();
helper.add(5, 3); // Error
```

"

### ‡ß™. Private fields (#) ‡¶è‡¶¨‡¶Ç underscore (\_) convention ‡¶è‡¶∞ ‡¶™‡¶æ‡¶∞‡ßç‡¶•‡¶ï‡ßç‡¶Ø?

**‡¶â‡¶§‡ßç‡¶§‡¶∞:**

```javascript
// ‚ùå Underscore - ‡¶∂‡ßÅ‡¶ß‡ßÅ convention, truly private ‡¶®‡¶æ
class OldWay {
  constructor() {
    this._private = "accessible";
  }
}
const old = new OldWay();
console.log(old._private); // Works (shouldn't!)

// ‚úÖ Hash - truly private
class NewWay {
  #private = "not accessible";
}
const newWay = new NewWay();
console.log(newWay.#private); // SyntaxError
```

`#` ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá truly private fields/methods ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º ‡¶Ø‡¶æ class ‡¶è‡¶∞ ‡¶¨‡¶æ‡¶á‡¶∞‡ßá ‡¶•‡ßá‡¶ï‡ßá access ‡¶ï‡¶∞‡¶æ impossible‡•§"

### ‡ß´. ‡¶è‡¶á code ‡¶è‡¶∞ output ‡¶ï‡¶ø?

```javascript
class Counter {
  static count = 0;

  constructor() {
    Counter.count++;
    this.id = Counter.count;
  }
}

const c1 = new Counter();
const c2 = new Counter();
const c3 = new Counter();

console.log(c1.id);
console.log(c2.id);
console.log(c3.id);
console.log(Counter.count);
```

**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
"Output:

```
1
2
3
3
```

**Explanation:**

- `Counter.count` static property ‡¶Ø‡¶æ ‡¶∏‡¶¨ instances share ‡¶ï‡¶∞‡ßá
- ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶æ new instance ‡¶§‡ßà‡¶∞‡¶ø ‡¶π‡¶≤‡ßá `count` increment ‡¶π‡¶Ø‡¶º
- ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶æ instance ‡¶®‡¶ø‡¶ú‡¶∏‡ßç‡¶¨ `id` ‡¶™‡¶æ‡¶Ø‡¶º current count value
- Final count = 3 (total instances)"

### ‡ß¨. Inheritance ‡¶è super keyword ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá?

**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
"`super` keyword ‡¶¶‡ßÅ‡¶á‡¶≠‡¶æ‡¶¨‡ßá use ‡¶π‡¶Ø‡¶º:

1. **Constructor ‡¶è:** Parent constructor call ‡¶ï‡¶∞‡¶§‡ßá
2. **Methods ‡¶è:** Parent methods access ‡¶ï‡¶∞‡¶§‡ßá

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    return `${this.name} makes a sound`;
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name); // Parent constructor call - MUST be first
    this.breed = breed;
  }

  speak() {
    const parentSpeak = super.speak(); // Parent method call
    return `${parentSpeak} - Woof!`;
  }
}

const dog = new Dog("Max", "Labrador");
console.log(dog.speak()); // 'Max makes a sound - Woof!'
```

**Important:** Child constructor ‡¶è `super()` call ‡¶ï‡¶∞‡¶æ mandatory `this` use ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶Ü‡¶ó‡ßá‡•§"

### ‡ß≠. Method overriding ‡¶ï‡¶ø?

**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
"Method overriding ‡¶π‡¶≤‡ßã child class ‡¶è parent class ‡¶è‡¶∞ method ‡¶ï‡ßá ‡¶®‡¶§‡ßÅ‡¶®‡¶≠‡¶æ‡¶¨‡ßá define ‡¶ï‡¶∞‡¶æ‡•§

```javascript
class Shape {
  getArea() {
    return 0;
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }

  // Overriding parent method
  getArea() {
    return this.width * this.height;
  }
}

class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }

  // Overriding parent method
  getArea() {
    return Math.PI * this.radius ** 2;
  }
}

const rect = new Rectangle(10, 5);
const circle = new Circle(7);

console.log(rect.getArea()); // 50
console.log(circle.getArea()); // 153.94
```

Same method name ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ different implementation‡•§"

---

## 9. ADVANCED CONCEPTS

### instanceof Operator

```javascript
class Animal {}
class Dog extends Animal {}
class Cat extends Animal {}

const dog = new Dog();
const cat = new Cat();

console.log(dog instanceof Dog); // true
console.log(dog instanceof Animal); // true
console.log(dog instanceof Cat); // false

console.log(cat instanceof Cat); // true
console.log(cat instanceof Animal); // true
console.log(cat instanceof Dog); // false
```

### Object.getPrototypeOf()

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }
}

const john = new Person("John");

console.log(Object.getPrototypeOf(john) === Person.prototype); // true
console.log(john.__proto__ === Person.prototype); // true (deprecated)
```

### Method Chaining

```javascript
class Calculator {
  constructor() {
    this.value = 0;
  }

  add(n) {
    this.value += n;
    return this; // Return instance for chaining
  }

  subtract(n) {
    this.value -= n;
    return this;
  }

  multiply(n) {
    this.value *= n;
    return this;
  }

  divide(n) {
    if (n !== 0) {
      this.value /= n;
    }
    return this;
  }

  getResult() {
    return this.value;
  }
}

// Chaining
const result = new Calculator()
  .add(10)
  .multiply(2)
  .subtract(5)
  .divide(3)
  .getResult();

console.log(result); // 5
```

### Abstract-like Classes (Simulation)

JavaScript ‡¶è true abstract classes ‡¶®‡¶æ‡¶á, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ simulate ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º:

```javascript
class AbstractShape {
  constructor() {
    if (new.target === AbstractShape) {
      throw new Error("Cannot instantiate abstract class");
    }
  }

  // "Abstract method" - child class implement ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶¨‡ßá
  getArea() {
    throw new Error("Method 'getArea()' must be implemented");
  }

  getPerimeter() {
    throw new Error("Method 'getPerimeter()' must be implemented");
  }
}

class Rectangle extends AbstractShape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }

  getPerimeter() {
    return 2 * (this.width + this.height);
  }
}

// ‚ùå This will throw error
// const shape = new AbstractShape();

// ‚úÖ This works
const rect = new Rectangle(10, 5);
console.log(rect.getArea()); // 50
```

### Mixins (Multiple Inheritance Simulation)

JavaScript single inheritance support ‡¶ï‡¶∞‡ßá, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ mixins ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá multiple behaviors add ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º:

```javascript
// Mixin functions
const canEat = {
  eat(food) {
    console.log(`${this.name} is eating ${food}`);
  },
};

const canWalk = {
  walk() {
    console.log(`${this.name} is walking`);
  },
};

const canSwim = {
  swim() {
    console.log(`${this.name} is swimming`);
  },
};

// Base class
class Animal {
  constructor(name) {
    this.name = name;
  }
}

// Apply mixins
class Dog extends Animal {}
Object.assign(Dog.prototype, canEat, canWalk);

class Fish extends Animal {}
Object.assign(Fish.prototype, canEat, canSwim);

class Duck extends Animal {}
Object.assign(Duck.prototype, canEat, canWalk, canSwim);

// Usage
const dog = new Dog("Buddy");
dog.eat("bone"); // "Buddy is eating bone"
dog.walk(); // "Buddy is walking"
// dog.swim();    // Error - dogs can't swim in our model

const fish = new Fish("Nemo");
fish.eat("plankton"); // "Nemo is eating plankton"
fish.swim(); // "Nemo is swimming"
// fish.walk();       // Error - fish can't walk

const duck = new Duck("Donald");
duck.eat("bread"); // "Donald is eating bread"
duck.walk(); // "Donald is walking"
duck.swim(); // "Donald is swimming"
```

---

## 10. DESIGN PATTERNS WITH CLASSES

### Singleton Pattern

‡¶∂‡ßÅ‡¶ß‡ßÅ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ ‡¶è‡¶ï‡¶ü‡¶æ instance ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá:

```javascript
class Database {
  static #instance = null;
  #connected = false;

  constructor() {
    if (Database.#instance) {
      return Database.#instance;
    }

    Database.#instance = this;
    this.#connected = false;
  }

  connect() {
    if (!this.#connected) {
      console.log("Connecting to database...");
      this.#connected = true;
    }
    return this;
  }

  disconnect() {
    if (this.#connected) {
      console.log("Disconnecting from database...");
      this.#connected = false;
    }
    return this;
  }

  query(sql) {
    if (!this.#connected) {
      console.log("Not connected!");
      return;
    }
    console.log(`Executing: ${sql}`);
  }

  get isConnected() {
    return this.#connected;
  }
}

// Multiple instances create ‡¶ï‡¶∞‡¶≤‡ßá‡¶ì same instance ‡¶™‡¶æ‡¶¨‡ßá
const db1 = new Database();
const db2 = new Database();

console.log(db1 === db2); // true - same instance!

db1.connect();
console.log(db2.isConnected); // true - shared state
```

### Factory Pattern

```javascript
class Car {
  constructor(brand, model, type) {
    this.brand = brand;
    this.model = model;
    this.type = type;
  }

  getInfo() {
    return `${this.brand} ${this.model} (${this.type})`;
  }
}

class CarFactory {
  static createSedan(brand, model) {
    return new Car(brand, model, "Sedan");
  }

  static createSUV(brand, model) {
    return new Car(brand, model, "SUV");
  }

  static createHatchback(brand, model) {
    return new Car(brand, model, "Hatchback");
  }

  static createCar(type, brand, model) {
    switch (type.toLowerCase()) {
      case "sedan":
        return this.createSedan(brand, model);
      case "suv":
        return this.createSUV(brand, model);
      case "hatchback":
        return this.createHatchback(brand, model);
      default:
        throw new Error("Unknown car type");
    }
  }
}

// Usage
const sedan = CarFactory.createSedan("Toyota", "Corolla");
const suv = CarFactory.createSUV("Honda", "CR-V");
const hatchback = CarFactory.createHatchback("Suzuki", "Swift");

console.log(sedan.getInfo()); // "Toyota Corolla (Sedan)"
console.log(suv.getInfo()); // "Honda CR-V (SUV)"

// Dynamic creation
const car = CarFactory.createCar("SUV", "Mazda", "CX-5");
console.log(car.getInfo()); // "Mazda CX-5 (SUV)"
```

### Builder Pattern

Complex objects ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø:

```javascript
class Pizza {
  constructor(builder) {
    this.size = builder.size;
    this.cheese = builder.cheese;
    this.pepperoni = builder.pepperoni;
    this.mushrooms = builder.mushrooms;
    this.olives = builder.olives;
  }

  getDescription() {
    const toppings = [];
    if (this.cheese) toppings.push("cheese");
    if (this.pepperoni) toppings.push("pepperoni");
    if (this.mushrooms) toppings.push("mushrooms");
    if (this.olives) toppings.push("olives");

    return `${this.size} pizza with ${toppings.join(", ")}`;
  }
}

class PizzaBuilder {
  constructor(size) {
    this.size = size;
    this.cheese = false;
    this.pepperoni = false;
    this.mushrooms = false;
    this.olives = false;
  }

  addCheese() {
    this.cheese = true;
    return this; // For chaining
  }

  addPepperoni() {
    this.pepperoni = true;
    return this;
  }

  addMushrooms() {
    this.mushrooms = true;
    return this;
  }

  addOlives() {
    this.olives = true;
    return this;
  }

  build() {
    return new Pizza(this);
  }
}

// Usage - Clean and readable
const pizza = new PizzaBuilder("Large")
  .addCheese()
  .addPepperoni()
  .addMushrooms()
  .build();

console.log(pizza.getDescription());
// "Large pizza with cheese, pepperoni, mushrooms"
```

### Observer Pattern

```javascript
class EventEmitter {
  #events = {};

  on(event, listener) {
    if (!this.#events[event]) {
      this.#events[event] = [];
    }
    this.#events[event].push(listener);
  }

  off(event, listenerToRemove) {
    if (!this.#events[event]) return;

    this.#events[event] = this.#events[event].filter(
      (listener) => listener !== listenerToRemove
    );
  }

  emit(event, ...args) {
    if (!this.#events[event]) return;

    this.#events[event].forEach((listener) => {
      listener(...args);
    });
  }
}

class User extends EventEmitter {
  #name;
  #email;

  constructor(name, email) {
    super();
    this.#name = name;
    this.#email = email;
  }

  get name() {
    return this.#name;
  }

  set name(value) {
    const oldName = this.#name;
    this.#name = value;
    this.emit("nameChanged", { oldName, newName: value });
  }

  get email() {
    return this.#email;
  }

  set email(value) {
    const oldEmail = this.#email;
    this.#email = value;
    this.emit("emailChanged", { oldEmail, newEmail: value });
  }
}

// Usage
const user = new User("John", "john@example.com");

// Subscribe to events
user.on("nameChanged", (data) => {
  console.log(`Name changed from ${data.oldName} to ${data.newName}`);
});

user.on("emailChanged", (data) => {
  console.log(`Email changed from ${data.oldEmail} to ${data.newEmail}`);
});

// Trigger events
user.name = "Jane"; // "Name changed from John to Jane"
user.email = "jane@example.com"; // "Email changed from..."
```

---

## 11. REAL-WORLD PROJECT: Task Management System

```javascript
// Task class
class Task {
  static #idCounter = 0;
  #id;
  #title;
  #description;
  #status;
  #priority;
  #createdAt;
  #updatedAt;
  #tags;

  constructor(title, description, priority = "medium") {
    this.#id = ++Task.#idCounter;
    this.#title = title;
    this.#description = description;
    this.#status = "pending";
    this.#priority = priority;
    this.#createdAt = new Date();
    this.#updatedAt = new Date();
    this.#tags = [];
  }

  // Getters
  get id() {
    return this.#id;
  }
  get title() {
    return this.#title;
  }
  get description() {
    return this.#description;
  }
  get status() {
    return this.#status;
  }
  get priority() {
    return this.#priority;
  }
  get createdAt() {
    return this.#createdAt;
  }
  get updatedAt() {
    return this.#updatedAt;
  }
  get tags() {
    return [...this.#tags];
  }

  // Setters with validation
  set title(value) {
    if (value.length < 3) {
      throw new Error("Title must be at least 3 characters");
    }
    this.#title = value;
    this.#updateTimestamp();
  }

  set description(value) {
    this.#description = value;
    this.#updateTimestamp();
  }

  set status(value) {
    const validStatuses = ["pending", "in-progress", "completed", "cancelled"];
    if (!validStatuses.includes(value)) {
      throw new Error(
        `Invalid status. Must be one of: ${validStatuses.join(", ")}`
      );
    }
    this.#status = value;
    this.#updateTimestamp();
  }

  set priority(value) {
    const validPriorities = ["low", "medium", "high", "urgent"];
    if (!validPriorities.includes(value)) {
      throw new Error(
        `Invalid priority. Must be one of: ${validPriorities.join(", ")}`
      );
    }
    this.#priority = value;
    this.#updateTimestamp();
  }

  // Methods
  addTag(tag) {
    if (!this.#tags.includes(tag)) {
      this.#tags.push(tag);
      this.#updateTimestamp();
    }
  }

  removeTag(tag) {
    const index = this.#tags.indexOf(tag);
    if (index > -1) {
      this.#tags.splice(index, 1);
      this.#updateTimestamp();
    }
  }

  #updateTimestamp() {
    this.#updatedAt = new Date();
  }

  complete() {
    this.status = "completed";
  }

  cancel() {
    this.status = "cancelled";
  }

  start() {
    this.status = "in-progress";
  }

  getInfo() {
    return {
      id: this.#id,
      title: this.#title,
      description: this.#description,
      status: this.#status,
      priority: this.#priority,
      tags: this.tags,
      createdAt: this.#createdAt,
      updatedAt: this.#updatedAt,
    };
  }

  toString() {
    return `[${this.#id}] ${this.#title} (${this.#status}) - ${
      this.#priority
    } priority`;
  }
}

// TaskManager class
class TaskManager {
  #tasks = [];

  addTask(title, description, priority) {
    const task = new Task(title, description, priority);
    this.#tasks.push(task);
    console.log(`‚úì Task added: ${task.title}`);
    return task;
  }

  removeTask(id) {
    const index = this.#tasks.findIndex((task) => task.id === id);
    if (index > -1) {
      const removed = this.#tasks.splice(index, 1)[0];
      console.log(`‚úì Task removed: ${removed.title}`);
      return true;
    }
    console.log(`‚úó Task not found with id: ${id}`);
    return false;
  }

  getTask(id) {
    return this.#tasks.find((task) => task.id === id);
  }

  getAllTasks() {
    return [...this.#tasks];
  }

  getTasksByStatus(status) {
    return this.#tasks.filter((task) => task.status === status);
  }

  getTasksByPriority(priority) {
    return this.#tasks.filter((task) => task.priority === priority);
  }

  getTasksByTag(tag) {
    return this.#tasks.filter((task) => task.tags.includes(tag));
  }

  searchTasks(query) {
    const lowerQuery = query.toLowerCase();
    return this.#tasks.filter(
      (task) =>
        task.title.toLowerCase().includes(lowerQuery) ||
        task.description.toLowerCase().includes(lowerQuery)
    );
  }

  get totalTasks() {
    return this.#tasks.length;
  }

  get completedTasks() {
    return this.#tasks.filter((task) => task.status === "completed").length;
  }

  get pendingTasks() {
    return this.#tasks.filter((task) => task.status === "pending").length;
  }

  get inProgressTasks() {
    return this.#tasks.filter((task) => task.status === "in-progress").length;
  }

  getStatistics() {
    return {
      total: this.totalTasks,
      completed: this.completedTasks,
      pending: this.pendingTasks,
      inProgress: this.inProgressTasks,
      cancelled: this.#tasks.filter((t) => t.status === "cancelled").length,
    };
  }

  displayAllTasks() {
    if (this.#tasks.length === 0) {
      console.log("No tasks available.");
      return;
    }

    console.log("\n========== ALL TASKS ==========");
    this.#tasks.forEach((task) => {
      console.log(task.toString());
    });
    console.log("===============================\n");
  }

  displayTasksByStatus(status) {
    const tasks = this.getTasksByStatus(status);
    console.log(`\n========== ${status.toUpperCase()} TASKS ==========`);
    if (tasks.length === 0) {
      console.log(`No ${status} tasks.`);
    } else {
      tasks.forEach((task) => console.log(task.toString()));
    }
    console.log("===============================\n");
  }

  clearCompleted() {
    const before = this.#tasks.length;
    this.#tasks = this.#tasks.filter((task) => task.status !== "completed");
    const removed = before - this.#tasks.length;
    console.log(`‚úì Removed ${removed} completed task(s)`);
  }
}

// Usage Example
console.log("===== TASK MANAGEMENT SYSTEM =====\n");

const manager = new TaskManager();

// Add tasks
const task1 = manager.addTask(
  "Complete JavaScript tutorial",
  "Finish learning Classes and Objects",
  "high"
);
task1.addTag("learning");
task1.addTag("javascript");

const task2 = manager.addTask(
  "Build portfolio website",
  "Create a responsive portfolio with React",
  "medium"
);
task2.addTag("project");
task2.addTag("react");

const task3 = manager.addTask(
  "Read JavaScript book",
  "Read 'You Don't Know JS' series",
  "low"
);
task3.addTag("learning");
task3.addTag("books");

// Display all tasks
manager.displayAllTasks();

// Update task status
task1.start();
console.log(`‚úì Started task: ${task1.title}`);

task3.complete();
console.log(`‚úì Completed task: ${task3.title}`);

// Display by status
manager.displayTasksByStatus("pending");
manager.displayTasksByStatus("in-progress");
manager.displayTasksByStatus("completed");

// Statistics
console.log("===== STATISTICS =====");
const stats = manager.getStatistics();
console.log(`Total tasks: ${stats.total}`);
console.log(`Completed: ${stats.completed}`);
console.log(`Pending: ${stats.pending}`);
console.log(`In Progress: ${stats.inProgress}`);
console.log("======================\n");

// Search
console.log("===== SEARCH RESULTS (JavaScript) =====");
const searchResults = manager.searchTasks("JavaScript");
searchResults.forEach((task) => console.log(task.toString()));

// Filter by tag
console.log("\n===== TASKS WITH 'learning' TAG =====");
const learningTasks = manager.getTasksByTag("learning");
learningTasks.forEach((task) => console.log(task.toString()));

// Clear completed
manager.clearCompleted();
manager.displayAllTasks();
```

---

## 12. COMMON PITFALLS & BEST PRACTICES

### Pitfall 1: Forgetting `new` keyword

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }
}

// ‚ùå Wrong - TypeError
const person = Person("John");

// ‚úÖ Correct
const person = new Person("John");
```

### Pitfall 2: Arrow functions as methods

```javascript
class Counter {
    count = 0;

    // ‚ùå Wrong - 'this' won't work properly
    increment: () => {
        this.count++; // 'this' refers to wrong context
    }

    // ‚úÖ Correct
    increment() {
        this.count++;
    }

    // ‚úÖ Also correct (for event handlers)
    incrementArrow = () => {
        this.count++;
    }
}
```

### Pitfall 3: Not calling super() in child constructor

```javascript
class Parent {
  constructor(name) {
    this.name = name;
  }
}

class Child extends Parent {
  constructor(name, age) {
    // ‚ùå ReferenceError: Must call super before accessing 'this'
    this.age = age;
    super(name);
  }
}

// ‚úÖ Correct
class ChildCorrect extends Parent {
  constructor(name, age) {
    super(name); // Call super first
    this.age = age;
  }
}
```

### Best Practices Summary

```javascript
// ‚úÖ DO:

// 1. Use meaningful class names (PascalCase)
class UserAccount {}

// 2. Use getters/setters for validation
class User {
  set email(value) {
    if (!value.includes("@")) {
      throw new Error("Invalid email");
    }
    this._email = value;
  }
}

// 3. Use private fields for encapsulation
class BankAccount {
  #balance = 0;
}

// 4. Use static methods for utilities
class MathHelper {
  static add(a, b) {
    return a + b;
  }
}

// 5. Return 'this' for method chaining
class Builder {
  setName(name) {
    this.name = name;
    return this;
  }
}

// ‚ùå DON'T:

// 1. Don't use classes for everything (simple objects are fine)
// 2. Don't make everything public
// 3. Don't forget to validate in setters
// 4. Don't create deep inheritance chains (prefer composition)
// 5. Don't mix arrow functions and regular methods without understanding
```

---

## Quick Reference Card

```javascript
// CLASS BASICS
class ClassName {
  // Constructor
  constructor(param) {
    this.property = param;
  }

  // Method
  method() {}

  // Getter
  get property() {
    return this._property;
  }

  // Setter
  set property(value) {
    this._property = value;
  }

  // Static method
  static staticMethod() {}

  // Private field
  #privateField = value;

  // Private method
  #privateMethod() {}
}

// INHERITANCE
class Child extends Parent {
  constructor(param) {
    super(param); // Call parent constructor
  }

  method() {
    super.method(); // Call parent method
  }
}

// USAGE
const instance = new ClassName(param);
instance.method();
instance.property = value;
const value = instance.property;
ClassName.staticMethod();
```

---

‡¶è‡¶á ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ guide practice ‡¶ï‡¶∞‡ßã ‡¶è‡¶¨‡¶Ç ‡¶®‡¶ø‡¶ú‡ßá code ‡¶≤‡¶ø‡¶ñ‡ßá test ‡¶ï‡¶∞‡ßã‡•§ Classes ‡¶è‡¶¨‡¶Ç Objects JavaScript ‡¶è‡¶∞ most important concepts, ‡¶è‡¶ó‡ßÅ‡¶≤‡ßã clear ‡¶•‡¶æ‡¶ï‡¶≤‡ßá modern JavaScript development ‡¶Ö‡¶®‡ßá‡¶ï ‡¶∏‡¶π‡¶ú ‡¶π‡¶¨‡ßá! üí™
